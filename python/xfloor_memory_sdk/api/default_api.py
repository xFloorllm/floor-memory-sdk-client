# coding: utf-8

"""
    Floor Memory

    The set APIs are used to develop Floor pds which can be used as their personal assistants. This set of APIs are divided into two parts.
    - Memory and
    - Registration. The developer has two ways of using the APIs for the app development. Developer can choose to the Registration APIs for using the existing xfloor infracture or can implement custom Registration process. In the case of custom registration process, the developer is bound to provide proper authentication mechanisms and then send the user information to xlfoor.

    The version of the OpenAPI document: 1.0.0
    Contact: contact@ipomo.in
    Generated by OpenAPI Generator (https://openapi-generator.tech)

    Do not edit the class manually.
"""  # noqa: E501

import warnings
from pydantic import validate_call, Field, StrictFloat, StrictStr, StrictInt
from typing import Any, Dict, List, Optional, Tuple, Union
from typing_extensions import Annotated

from pydantic import Field, StrictBytes, StrictStr
from typing import Any, Dict, Optional, Tuple, Union
from typing_extensions import Annotated
from xfloor_memory_sdk.models.change_password200_response import ChangePassword200Response
from xfloor_memory_sdk.models.conversation_threads200_response import ConversationThreads200Response
from xfloor_memory_sdk.models.get_conversations200_response import GetConversations200Response
from xfloor_memory_sdk.models.get_floor_information200_response import GetFloorInformation200Response
from xfloor_memory_sdk.models.reset_password200_response import ResetPassword200Response
from xfloor_memory_sdk.models.send_sign_in_validation_code200_response import SendSignInValidationCode200Response
from xfloor_memory_sdk.models.send_validation_code200_response import SendValidationCode200Response
from xfloor_memory_sdk.models.sign_in_with_email200_response import SignInWithEmail200Response
from xfloor_memory_sdk.models.sign_up200_response import SignUp200Response
from xfloor_memory_sdk.models.user_details import UserDetails
from xfloor_memory_sdk.models.validate_code_request import ValidateCodeRequest

from xfloor_memory_sdk.api_client import ApiClient, RequestSerialized
from xfloor_memory_sdk.api_response import ApiResponse
from xfloor_memory_sdk.rest import RESTResponseType


class DefaultApi:
    """NOTE: This class is auto generated by OpenAPI Generator
    Ref: https://openapi-generator.tech

    Do not edit the class manually.
    """

    def __init__(self, api_client=None) -> None:
        if api_client is None:
            api_client = ApiClient.get_default()
        self.api_client = api_client


    @validate_call
    def api_developer_create_app_post(
        self,
        input_info: StrictStr,
        icon: Optional[Union[StrictBytes, StrictStr, Tuple[StrictStr, StrictBytes]]] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> object:
        """Create App

        Create a custom app using APIs. A 13 digit app ID gets created which takes title and description the app. An icon of specified size needs to be uploaded.

        :param input_info: (required)
        :type input_info: str
        :param icon:
        :type icon: bytearray
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._api_developer_create_app_post_serialize(
            input_info=input_info,
            icon=icon,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "object",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        ).data


    @validate_call
    def api_developer_create_app_post_with_http_info(
        self,
        input_info: StrictStr,
        icon: Optional[Union[StrictBytes, StrictStr, Tuple[StrictStr, StrictBytes]]] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> ApiResponse[object]:
        """Create App

        Create a custom app using APIs. A 13 digit app ID gets created which takes title and description the app. An icon of specified size needs to be uploaded.

        :param input_info: (required)
        :type input_info: str
        :param icon:
        :type icon: bytearray
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._api_developer_create_app_post_serialize(
            input_info=input_info,
            icon=icon,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "object",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        )


    @validate_call
    def api_developer_create_app_post_without_preload_content(
        self,
        input_info: StrictStr,
        icon: Optional[Union[StrictBytes, StrictStr, Tuple[StrictStr, StrictBytes]]] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> RESTResponseType:
        """Create App

        Create a custom app using APIs. A 13 digit app ID gets created which takes title and description the app. An icon of specified size needs to be uploaded.

        :param input_info: (required)
        :type input_info: str
        :param icon:
        :type icon: bytearray
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._api_developer_create_app_post_serialize(
            input_info=input_info,
            icon=icon,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "object",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        return response_data.response


    def _api_developer_create_app_post_serialize(
        self,
        input_info,
        icon,
        _request_auth,
        _content_type,
        _headers,
        _host_index,
    ) -> RequestSerialized:

        _host = None

        _collection_formats: Dict[str, str] = {
        }

        _path_params: Dict[str, str] = {}
        _query_params: List[Tuple[str, str]] = []
        _header_params: Dict[str, Optional[str]] = _headers or {}
        _form_params: List[Tuple[str, str]] = []
        _files: Dict[
            str, Union[str, bytes, List[str], List[bytes], List[Tuple[str, bytes]]]
        ] = {}
        _body_params: Optional[bytes] = None

        # process the path parameters
        # process the query parameters
        # process the header parameters
        # process the form parameters
        if input_info is not None:
            _form_params.append(('input_info', input_info))
        if icon is not None:
            _files['icon'] = icon
        # process the body parameter


        # set the HTTP header `Accept`
        if 'Accept' not in _header_params:
            _header_params['Accept'] = self.api_client.select_header_accept(
                [
                    'application/json'
                ]
            )

        # set the HTTP header `Content-Type`
        if _content_type:
            _header_params['Content-Type'] = _content_type
        else:
            _default_content_type = (
                self.api_client.select_header_content_type(
                    [
                        'multipart/form-data'
                    ]
                )
            )
            if _default_content_type is not None:
                _header_params['Content-Type'] = _default_content_type

        # authentication setting
        _auth_settings: List[str] = [
        ]

        return self.api_client.param_serialize(
            method='POST',
            resource_path='/api/developer/create/app',
            path_params=_path_params,
            query_params=_query_params,
            header_params=_header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            auth_settings=_auth_settings,
            collection_formats=_collection_formats,
            _host=_host,
            _request_auth=_request_auth
        )




    @validate_call
    def api_developer_modify_app_post(
        self,
        input_info: Annotated[StrictStr, Field(description="User ID, App ID, Title, Details. User ID and App ID are required parameters. Title/details are optional.")],
        file: Annotated[Optional[Union[StrictBytes, StrictStr, Tuple[StrictStr, StrictBytes]]], Field(description="Upload the new PNG icon file.")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> object:
        """Modify Floorpod App

        Modify title, details or the app icon

        :param input_info: User ID, App ID, Title, Details. User ID and App ID are required parameters. Title/details are optional. (required)
        :type input_info: str
        :param file: Upload the new PNG icon file.
        :type file: bytearray
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._api_developer_modify_app_post_serialize(
            input_info=input_info,
            file=file,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "object",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        ).data


    @validate_call
    def api_developer_modify_app_post_with_http_info(
        self,
        input_info: Annotated[StrictStr, Field(description="User ID, App ID, Title, Details. User ID and App ID are required parameters. Title/details are optional.")],
        file: Annotated[Optional[Union[StrictBytes, StrictStr, Tuple[StrictStr, StrictBytes]]], Field(description="Upload the new PNG icon file.")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> ApiResponse[object]:
        """Modify Floorpod App

        Modify title, details or the app icon

        :param input_info: User ID, App ID, Title, Details. User ID and App ID are required parameters. Title/details are optional. (required)
        :type input_info: str
        :param file: Upload the new PNG icon file.
        :type file: bytearray
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._api_developer_modify_app_post_serialize(
            input_info=input_info,
            file=file,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "object",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        )


    @validate_call
    def api_developer_modify_app_post_without_preload_content(
        self,
        input_info: Annotated[StrictStr, Field(description="User ID, App ID, Title, Details. User ID and App ID are required parameters. Title/details are optional.")],
        file: Annotated[Optional[Union[StrictBytes, StrictStr, Tuple[StrictStr, StrictBytes]]], Field(description="Upload the new PNG icon file.")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> RESTResponseType:
        """Modify Floorpod App

        Modify title, details or the app icon

        :param input_info: User ID, App ID, Title, Details. User ID and App ID are required parameters. Title/details are optional. (required)
        :type input_info: str
        :param file: Upload the new PNG icon file.
        :type file: bytearray
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._api_developer_modify_app_post_serialize(
            input_info=input_info,
            file=file,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "object",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        return response_data.response


    def _api_developer_modify_app_post_serialize(
        self,
        input_info,
        file,
        _request_auth,
        _content_type,
        _headers,
        _host_index,
    ) -> RequestSerialized:

        _host = None

        _collection_formats: Dict[str, str] = {
        }

        _path_params: Dict[str, str] = {}
        _query_params: List[Tuple[str, str]] = []
        _header_params: Dict[str, Optional[str]] = _headers or {}
        _form_params: List[Tuple[str, str]] = []
        _files: Dict[
            str, Union[str, bytes, List[str], List[bytes], List[Tuple[str, bytes]]]
        ] = {}
        _body_params: Optional[bytes] = None

        # process the path parameters
        # process the query parameters
        # process the header parameters
        # process the form parameters
        if input_info is not None:
            _form_params.append(('input_info', input_info))
        if file is not None:
            _files['file'] = file
        # process the body parameter


        # set the HTTP header `Accept`
        if 'Accept' not in _header_params:
            _header_params['Accept'] = self.api_client.select_header_accept(
                [
                    'application/json'
                ]
            )

        # set the HTTP header `Content-Type`
        if _content_type:
            _header_params['Content-Type'] = _content_type
        else:
            _default_content_type = (
                self.api_client.select_header_content_type(
                    [
                        'multipart/form-data'
                    ]
                )
            )
            if _default_content_type is not None:
                _header_params['Content-Type'] = _default_content_type

        # authentication setting
        _auth_settings: List[str] = [
        ]

        return self.api_client.param_serialize(
            method='POST',
            resource_path='/api/developer/modify/app',
            path_params=_path_params,
            query_params=_query_params,
            header_params=_header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            auth_settings=_auth_settings,
            collection_formats=_collection_formats,
            _host=_host,
            _request_auth=_request_auth
        )




    @validate_call
    def change_email(
        self,
        new_email_id: Annotated[StrictStr, Field(description="New Email ID")],
        activation_code: Annotated[StrictStr, Field(description="Validation code")],
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> object:
        """Change email ID

        Updates the email ID associated with an existing user account after validating a one-time activation code sent to the **new email address**. This operation can only be performed by a **logged-in user**. When a user initiates an email change, an activation code is sent to the newly provided email ID. The email update takes effect only after the activation code is successfully validated. If the activation code validation fails, the email ID remains unchanged.
        
        ---
        
        ### **Authentication**
        
        This endpoint requires **Bearer Token authentication**.
        
        ``` Authorization: Bearer <access_token>
        
        ```
        
        ---
        
        ### **Request Body**
        
        ```json { \"user_id\": \"string\", \"new_email_id\": \"string\", \"activation_code\": \"string\", \"app_id\":\"string\" }
        
        ``` **Field Description**
        * `user_id` – Unique identifier of the logged-in user
        * `new_email_id` – New email address to be associated with the account * `activation_code` – One-time activation code sent to the new email ID for verification
        
        ---
        
        ### **Flow Summary**
        1. User is authenticated and logged in
        2. User requests to change email ID 3. System sends an activation code to the **new email address**
        4. User submits the activation code via this API
        5. On successful validation, the email ID is updated
        
        ---
        
        ### **Successful Response**
        
        On successful validation:
        * The activation code is verified
        * The user’s email ID is updated immediately * A `success` string is returned confirming the email change
        
        ---
        
        ### **Error Response**
        
         The API returns an error response if:
        * The activation code is invalid or expired
        * The activation code does not match the user or email * The new email ID is already in use * Authorization fails or the bearer token is missing or invalid In all error cases, the existing email ID remains unchanged.
        
        ---
        
        ### **Behavior
        
        Notes**
        * Requires a prior call to `/auth-service/send/validation/code` with the proper mode.
        
        ---
        
        ### **Security
        
        Notes (Recommended)**
        * Activation codes are single-use and time-bound
        * Email changes require prior authentication * Rate limiting may be applied to prevent abuse
        
        ---
        
        ### **One-Line Summary**
        
        > Changes a user’s email ID after validating an activation code sent to the new email address.

        :param new_email_id: New Email ID (required)
        :type new_email_id: str
        :param activation_code: Validation code (required)
        :type activation_code: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._change_email_serialize(
            new_email_id=new_email_id,
            activation_code=activation_code,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "object",
            '400': "GetRecentEvents400Response",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        ).data


    @validate_call
    def change_email_with_http_info(
        self,
        new_email_id: Annotated[StrictStr, Field(description="New Email ID")],
        activation_code: Annotated[StrictStr, Field(description="Validation code")],
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> ApiResponse[object]:
        """Change email ID

        Updates the email ID associated with an existing user account after validating a one-time activation code sent to the **new email address**. This operation can only be performed by a **logged-in user**. When a user initiates an email change, an activation code is sent to the newly provided email ID. The email update takes effect only after the activation code is successfully validated. If the activation code validation fails, the email ID remains unchanged.
        
        ---
        
        ### **Authentication**
        
        This endpoint requires **Bearer Token authentication**.
        
        ``` Authorization: Bearer <access_token>
        
        ```
        
        ---
        
        ### **Request Body**
        
        ```json { \"user_id\": \"string\", \"new_email_id\": \"string\", \"activation_code\": \"string\", \"app_id\":\"string\" }
        
        ``` **Field Description**
        * `user_id` – Unique identifier of the logged-in user
        * `new_email_id` – New email address to be associated with the account * `activation_code` – One-time activation code sent to the new email ID for verification
        
        ---
        
        ### **Flow Summary**
        1. User is authenticated and logged in
        2. User requests to change email ID 3. System sends an activation code to the **new email address**
        4. User submits the activation code via this API
        5. On successful validation, the email ID is updated
        
        ---
        
        ### **Successful Response**
        
        On successful validation:
        * The activation code is verified
        * The user’s email ID is updated immediately * A `success` string is returned confirming the email change
        
        ---
        
        ### **Error Response**
        
         The API returns an error response if:
        * The activation code is invalid or expired
        * The activation code does not match the user or email * The new email ID is already in use * Authorization fails or the bearer token is missing or invalid In all error cases, the existing email ID remains unchanged.
        
        ---
        
        ### **Behavior
        
        Notes**
        * Requires a prior call to `/auth-service/send/validation/code` with the proper mode.
        
        ---
        
        ### **Security
        
        Notes (Recommended)**
        * Activation codes are single-use and time-bound
        * Email changes require prior authentication * Rate limiting may be applied to prevent abuse
        
        ---
        
        ### **One-Line Summary**
        
        > Changes a user’s email ID after validating an activation code sent to the new email address.

        :param new_email_id: New Email ID (required)
        :type new_email_id: str
        :param activation_code: Validation code (required)
        :type activation_code: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._change_email_serialize(
            new_email_id=new_email_id,
            activation_code=activation_code,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "object",
            '400': "GetRecentEvents400Response",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        )


    @validate_call
    def change_email_without_preload_content(
        self,
        new_email_id: Annotated[StrictStr, Field(description="New Email ID")],
        activation_code: Annotated[StrictStr, Field(description="Validation code")],
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> RESTResponseType:
        """Change email ID

        Updates the email ID associated with an existing user account after validating a one-time activation code sent to the **new email address**. This operation can only be performed by a **logged-in user**. When a user initiates an email change, an activation code is sent to the newly provided email ID. The email update takes effect only after the activation code is successfully validated. If the activation code validation fails, the email ID remains unchanged.
        
        ---
        
        ### **Authentication**
        
        This endpoint requires **Bearer Token authentication**.
        
        ``` Authorization: Bearer <access_token>
        
        ```
        
        ---
        
        ### **Request Body**
        
        ```json { \"user_id\": \"string\", \"new_email_id\": \"string\", \"activation_code\": \"string\", \"app_id\":\"string\" }
        
        ``` **Field Description**
        * `user_id` – Unique identifier of the logged-in user
        * `new_email_id` – New email address to be associated with the account * `activation_code` – One-time activation code sent to the new email ID for verification
        
        ---
        
        ### **Flow Summary**
        1. User is authenticated and logged in
        2. User requests to change email ID 3. System sends an activation code to the **new email address**
        4. User submits the activation code via this API
        5. On successful validation, the email ID is updated
        
        ---
        
        ### **Successful Response**
        
        On successful validation:
        * The activation code is verified
        * The user’s email ID is updated immediately * A `success` string is returned confirming the email change
        
        ---
        
        ### **Error Response**
        
         The API returns an error response if:
        * The activation code is invalid or expired
        * The activation code does not match the user or email * The new email ID is already in use * Authorization fails or the bearer token is missing or invalid In all error cases, the existing email ID remains unchanged.
        
        ---
        
        ### **Behavior
        
        Notes**
        * Requires a prior call to `/auth-service/send/validation/code` with the proper mode.
        
        ---
        
        ### **Security
        
        Notes (Recommended)**
        * Activation codes are single-use and time-bound
        * Email changes require prior authentication * Rate limiting may be applied to prevent abuse
        
        ---
        
        ### **One-Line Summary**
        
        > Changes a user’s email ID after validating an activation code sent to the new email address.

        :param new_email_id: New Email ID (required)
        :type new_email_id: str
        :param activation_code: Validation code (required)
        :type activation_code: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._change_email_serialize(
            new_email_id=new_email_id,
            activation_code=activation_code,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "object",
            '400': "GetRecentEvents400Response",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        return response_data.response


    def _change_email_serialize(
        self,
        new_email_id,
        activation_code,
        _request_auth,
        _content_type,
        _headers,
        _host_index,
    ) -> RequestSerialized:

        _host = None

        _collection_formats: Dict[str, str] = {
        }

        _path_params: Dict[str, str] = {}
        _query_params: List[Tuple[str, str]] = []
        _header_params: Dict[str, Optional[str]] = _headers or {}
        _form_params: List[Tuple[str, str]] = []
        _files: Dict[
            str, Union[str, bytes, List[str], List[bytes], List[Tuple[str, bytes]]]
        ] = {}
        _body_params: Optional[bytes] = None

        # process the path parameters
        # process the query parameters
        # process the header parameters
        # process the form parameters
        if new_email_id is not None:
            _form_params.append(('new_email_id', new_email_id))
        if activation_code is not None:
            _form_params.append(('activation_code', activation_code))
        # process the body parameter


        # set the HTTP header `Accept`
        if 'Accept' not in _header_params:
            _header_params['Accept'] = self.api_client.select_header_accept(
                [
                    'application/json'
                ]
            )

        # set the HTTP header `Content-Type`
        if _content_type:
            _header_params['Content-Type'] = _content_type
        else:
            _default_content_type = (
                self.api_client.select_header_content_type(
                    [
                        'multipart/form-data'
                    ]
                )
            )
            if _default_content_type is not None:
                _header_params['Content-Type'] = _default_content_type

        # authentication setting
        _auth_settings: List[str] = [
            'bearer'
        ]

        return self.api_client.param_serialize(
            method='POST',
            resource_path='/auth-service/change/email',
            path_params=_path_params,
            query_params=_query_params,
            header_params=_header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            auth_settings=_auth_settings,
            collection_formats=_collection_formats,
            _host=_host,
            _request_auth=_request_auth
        )




    @validate_call
    def change_mobile_number(
        self,
        body: Dict[str, Any],
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> object:
        """Change Mobile number

        Updates the mobile number associated with an existing user account after validating a one-time activation code sent to the **new mobile number**. This operation can only be performed by a **logged-in user**. When a user initiates a mobile number change, an activation code is sent to the newly provided mobile number. The mobile number update takes effect only after the activation code is successfully validated. If the activation code validation fails, the mobile number remains unchanged.
        
        ---
        
        ### **Authentication**
        
        This endpoint requires **Bearer Token authentication**.
        
        ``` Authorization: Bearer <access_token>
        
        ```
        
        ---
        
        ### **Request Body**
        
        ```json { \"user_id\": \"string\", \"new_mobile_number\": \"string\", \"activation_code\": \"string\" }
        
        ``` **Field Description**
        * `user_id` – Unique identifier of the logged-in user
        * `new_mobile_number` – New mobile number to be associated with the account * `activation_code` – One-time activation code sent to the new mobile number for verification
        
        ---
        
        ### **Flow Summary**
        1. User is authenticated and logged in
        2. User requests to change mobile number 3. System sends an activation code to the **new mobile number**
        4. User submits the activation code via this API
        5. On successful validation, the mobile number is updated
        
        ---
        
        ### **Successful Response**
        
        On successful validation:
        * The activation code is verified
        * The user’s mobile number is updated immediately * A `success` string is returned confirming the mobile number change
        
        ---
        
        ### **Error Response**
        
         The API returns an error response if:
        * The activation code is invalid or expired
        * The activation code does not match the user or mobile number * The new mobile number is already in use * Authorization fails or the bearer token is missing or invalid In all error cases, the existing mobile number remains unchanged.
        
        ---
        
        ### **Behavior
        
        Notes**
        * Requires a prior call to `/auth-service/send/validation/code` with the proper mode.
        
        ---
        
        ### **Security
        
        Notes (Recommended)**
        * Activation codes are single-use and time-bound
        * Mobile number changes require prior authentication * Rate limiting may be applied to prevent abuse
        
        ---
        
        ### **One-Line Summary**
        
        > Changes a user’s mobile number after validating an activation code sent to the new mobile number.

        :param body: (required)
        :type body: object
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._change_mobile_number_serialize(
            body=body,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "object",
            '400': "GetRecentEvents400Response",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        ).data


    @validate_call
    def change_mobile_number_with_http_info(
        self,
        body: Dict[str, Any],
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> ApiResponse[object]:
        """Change Mobile number

        Updates the mobile number associated with an existing user account after validating a one-time activation code sent to the **new mobile number**. This operation can only be performed by a **logged-in user**. When a user initiates a mobile number change, an activation code is sent to the newly provided mobile number. The mobile number update takes effect only after the activation code is successfully validated. If the activation code validation fails, the mobile number remains unchanged.
        
        ---
        
        ### **Authentication**
        
        This endpoint requires **Bearer Token authentication**.
        
        ``` Authorization: Bearer <access_token>
        
        ```
        
        ---
        
        ### **Request Body**
        
        ```json { \"user_id\": \"string\", \"new_mobile_number\": \"string\", \"activation_code\": \"string\" }
        
        ``` **Field Description**
        * `user_id` – Unique identifier of the logged-in user
        * `new_mobile_number` – New mobile number to be associated with the account * `activation_code` – One-time activation code sent to the new mobile number for verification
        
        ---
        
        ### **Flow Summary**
        1. User is authenticated and logged in
        2. User requests to change mobile number 3. System sends an activation code to the **new mobile number**
        4. User submits the activation code via this API
        5. On successful validation, the mobile number is updated
        
        ---
        
        ### **Successful Response**
        
        On successful validation:
        * The activation code is verified
        * The user’s mobile number is updated immediately * A `success` string is returned confirming the mobile number change
        
        ---
        
        ### **Error Response**
        
         The API returns an error response if:
        * The activation code is invalid or expired
        * The activation code does not match the user or mobile number * The new mobile number is already in use * Authorization fails or the bearer token is missing or invalid In all error cases, the existing mobile number remains unchanged.
        
        ---
        
        ### **Behavior
        
        Notes**
        * Requires a prior call to `/auth-service/send/validation/code` with the proper mode.
        
        ---
        
        ### **Security
        
        Notes (Recommended)**
        * Activation codes are single-use and time-bound
        * Mobile number changes require prior authentication * Rate limiting may be applied to prevent abuse
        
        ---
        
        ### **One-Line Summary**
        
        > Changes a user’s mobile number after validating an activation code sent to the new mobile number.

        :param body: (required)
        :type body: object
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._change_mobile_number_serialize(
            body=body,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "object",
            '400': "GetRecentEvents400Response",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        )


    @validate_call
    def change_mobile_number_without_preload_content(
        self,
        body: Dict[str, Any],
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> RESTResponseType:
        """Change Mobile number

        Updates the mobile number associated with an existing user account after validating a one-time activation code sent to the **new mobile number**. This operation can only be performed by a **logged-in user**. When a user initiates a mobile number change, an activation code is sent to the newly provided mobile number. The mobile number update takes effect only after the activation code is successfully validated. If the activation code validation fails, the mobile number remains unchanged.
        
        ---
        
        ### **Authentication**
        
        This endpoint requires **Bearer Token authentication**.
        
        ``` Authorization: Bearer <access_token>
        
        ```
        
        ---
        
        ### **Request Body**
        
        ```json { \"user_id\": \"string\", \"new_mobile_number\": \"string\", \"activation_code\": \"string\" }
        
        ``` **Field Description**
        * `user_id` – Unique identifier of the logged-in user
        * `new_mobile_number` – New mobile number to be associated with the account * `activation_code` – One-time activation code sent to the new mobile number for verification
        
        ---
        
        ### **Flow Summary**
        1. User is authenticated and logged in
        2. User requests to change mobile number 3. System sends an activation code to the **new mobile number**
        4. User submits the activation code via this API
        5. On successful validation, the mobile number is updated
        
        ---
        
        ### **Successful Response**
        
        On successful validation:
        * The activation code is verified
        * The user’s mobile number is updated immediately * A `success` string is returned confirming the mobile number change
        
        ---
        
        ### **Error Response**
        
         The API returns an error response if:
        * The activation code is invalid or expired
        * The activation code does not match the user or mobile number * The new mobile number is already in use * Authorization fails or the bearer token is missing or invalid In all error cases, the existing mobile number remains unchanged.
        
        ---
        
        ### **Behavior
        
        Notes**
        * Requires a prior call to `/auth-service/send/validation/code` with the proper mode.
        
        ---
        
        ### **Security
        
        Notes (Recommended)**
        * Activation codes are single-use and time-bound
        * Mobile number changes require prior authentication * Rate limiting may be applied to prevent abuse
        
        ---
        
        ### **One-Line Summary**
        
        > Changes a user’s mobile number after validating an activation code sent to the new mobile number.

        :param body: (required)
        :type body: object
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._change_mobile_number_serialize(
            body=body,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "object",
            '400': "GetRecentEvents400Response",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        return response_data.response


    def _change_mobile_number_serialize(
        self,
        body,
        _request_auth,
        _content_type,
        _headers,
        _host_index,
    ) -> RequestSerialized:

        _host = None

        _collection_formats: Dict[str, str] = {
        }

        _path_params: Dict[str, str] = {}
        _query_params: List[Tuple[str, str]] = []
        _header_params: Dict[str, Optional[str]] = _headers or {}
        _form_params: List[Tuple[str, str]] = []
        _files: Dict[
            str, Union[str, bytes, List[str], List[bytes], List[Tuple[str, bytes]]]
        ] = {}
        _body_params: Optional[bytes] = None

        # process the path parameters
        # process the query parameters
        # process the header parameters
        # process the form parameters
        # process the body parameter
        if body is not None:
            _body_params = body


        # set the HTTP header `Accept`
        if 'Accept' not in _header_params:
            _header_params['Accept'] = self.api_client.select_header_accept(
                [
                    'application/json'
                ]
            )

        # set the HTTP header `Content-Type`
        if _content_type:
            _header_params['Content-Type'] = _content_type
        else:
            _default_content_type = (
                self.api_client.select_header_content_type(
                    [
                        'application/json'
                    ]
                )
            )
            if _default_content_type is not None:
                _header_params['Content-Type'] = _default_content_type

        # authentication setting
        _auth_settings: List[str] = [
            'bearer'
        ]

        return self.api_client.param_serialize(
            method='POST',
            resource_path='/auth-service/change/mobile',
            path_params=_path_params,
            query_params=_query_params,
            header_params=_header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            auth_settings=_auth_settings,
            collection_formats=_collection_formats,
            _host=_host,
            _request_auth=_request_auth
        )




    @validate_call
    def change_password(
        self,
        new_password: Annotated[StrictStr, Field(description="New Password")],
        activation_code: Annotated[StrictStr, Field(description="Validation code")],
        user_id: Annotated[Optional[StrictStr], Field(description="User ID")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> ChangePassword200Response:
        """Change Password

        1) `POST /password/change` — Change Password (Logged-in User)
        
        Changes the password of an **authenticated user** who is currently logged in.
        
        This endpoint is used when a user is already signed in and wants to update their password as a security or preference action. The system validates a **one-time password-change verification code** (`activation_code`) issued specifically for the change-password flow. If the code is valid and not expired, the user’s password is updated to `new_password` and takes effect immediately. If verification fails, the password remains unchanged and an error response is returned.
        
        ### Authentication ✅ **Required**:
        
        Bearer token for the logged-in session
        
        ``` Authorization: Bearer <access_token>
        
        ```
        
        **Request Body**
        
        (Form Data)
        * `user_id` (optional if derived from token)
        * `activation_code` (required) * `new_password` (required)
        
        ### Behavior
        
        Notes
        * Typically requires a prior call to **send a verification code** for password change (mode = password change).
        * `user_id` can be taken from the access token; include it only if your system requires it explicitly.
        
        ### One-Line Summary > Changes the password for a logged-in user after validating a one-time password-change code.

        :param new_password: New Password (required)
        :type new_password: str
        :param activation_code: Validation code (required)
        :type activation_code: str
        :param user_id: User ID
        :type user_id: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._change_password_serialize(
            new_password=new_password,
            activation_code=activation_code,
            user_id=user_id,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "ChangePassword200Response",
            '400': "GetRecentEvents400Response",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        ).data


    @validate_call
    def change_password_with_http_info(
        self,
        new_password: Annotated[StrictStr, Field(description="New Password")],
        activation_code: Annotated[StrictStr, Field(description="Validation code")],
        user_id: Annotated[Optional[StrictStr], Field(description="User ID")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> ApiResponse[ChangePassword200Response]:
        """Change Password

        1) `POST /password/change` — Change Password (Logged-in User)
        
        Changes the password of an **authenticated user** who is currently logged in.
        
        This endpoint is used when a user is already signed in and wants to update their password as a security or preference action. The system validates a **one-time password-change verification code** (`activation_code`) issued specifically for the change-password flow. If the code is valid and not expired, the user’s password is updated to `new_password` and takes effect immediately. If verification fails, the password remains unchanged and an error response is returned.
        
        ### Authentication ✅ **Required**:
        
        Bearer token for the logged-in session
        
        ``` Authorization: Bearer <access_token>
        
        ```
        
        **Request Body**
        
        (Form Data)
        * `user_id` (optional if derived from token)
        * `activation_code` (required) * `new_password` (required)
        
        ### Behavior
        
        Notes
        * Typically requires a prior call to **send a verification code** for password change (mode = password change).
        * `user_id` can be taken from the access token; include it only if your system requires it explicitly.
        
        ### One-Line Summary > Changes the password for a logged-in user after validating a one-time password-change code.

        :param new_password: New Password (required)
        :type new_password: str
        :param activation_code: Validation code (required)
        :type activation_code: str
        :param user_id: User ID
        :type user_id: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._change_password_serialize(
            new_password=new_password,
            activation_code=activation_code,
            user_id=user_id,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "ChangePassword200Response",
            '400': "GetRecentEvents400Response",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        )


    @validate_call
    def change_password_without_preload_content(
        self,
        new_password: Annotated[StrictStr, Field(description="New Password")],
        activation_code: Annotated[StrictStr, Field(description="Validation code")],
        user_id: Annotated[Optional[StrictStr], Field(description="User ID")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> RESTResponseType:
        """Change Password

        1) `POST /password/change` — Change Password (Logged-in User)
        
        Changes the password of an **authenticated user** who is currently logged in.
        
        This endpoint is used when a user is already signed in and wants to update their password as a security or preference action. The system validates a **one-time password-change verification code** (`activation_code`) issued specifically for the change-password flow. If the code is valid and not expired, the user’s password is updated to `new_password` and takes effect immediately. If verification fails, the password remains unchanged and an error response is returned.
        
        ### Authentication ✅ **Required**:
        
        Bearer token for the logged-in session
        
        ``` Authorization: Bearer <access_token>
        
        ```
        
        **Request Body**
        
        (Form Data)
        * `user_id` (optional if derived from token)
        * `activation_code` (required) * `new_password` (required)
        
        ### Behavior
        
        Notes
        * Typically requires a prior call to **send a verification code** for password change (mode = password change).
        * `user_id` can be taken from the access token; include it only if your system requires it explicitly.
        
        ### One-Line Summary > Changes the password for a logged-in user after validating a one-time password-change code.

        :param new_password: New Password (required)
        :type new_password: str
        :param activation_code: Validation code (required)
        :type activation_code: str
        :param user_id: User ID
        :type user_id: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._change_password_serialize(
            new_password=new_password,
            activation_code=activation_code,
            user_id=user_id,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "ChangePassword200Response",
            '400': "GetRecentEvents400Response",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        return response_data.response


    def _change_password_serialize(
        self,
        new_password,
        activation_code,
        user_id,
        _request_auth,
        _content_type,
        _headers,
        _host_index,
    ) -> RequestSerialized:

        _host = None

        _collection_formats: Dict[str, str] = {
        }

        _path_params: Dict[str, str] = {}
        _query_params: List[Tuple[str, str]] = []
        _header_params: Dict[str, Optional[str]] = _headers or {}
        _form_params: List[Tuple[str, str]] = []
        _files: Dict[
            str, Union[str, bytes, List[str], List[bytes], List[Tuple[str, bytes]]]
        ] = {}
        _body_params: Optional[bytes] = None

        # process the path parameters
        # process the query parameters
        # process the header parameters
        # process the form parameters
        if user_id is not None:
            _form_params.append(('user_id', user_id))
        if new_password is not None:
            _form_params.append(('new_password', new_password))
        if activation_code is not None:
            _form_params.append(('activation_code', activation_code))
        # process the body parameter


        # set the HTTP header `Accept`
        if 'Accept' not in _header_params:
            _header_params['Accept'] = self.api_client.select_header_accept(
                [
                    'application/json'
                ]
            )

        # set the HTTP header `Content-Type`
        if _content_type:
            _header_params['Content-Type'] = _content_type
        else:
            _default_content_type = (
                self.api_client.select_header_content_type(
                    [
                        'multipart/form-data'
                    ]
                )
            )
            if _default_content_type is not None:
                _header_params['Content-Type'] = _default_content_type

        # authentication setting
        _auth_settings: List[str] = [
            'bearer'
        ]

        return self.api_client.param_serialize(
            method='POST',
            resource_path='/auth-service/password/change',
            path_params=_path_params,
            query_params=_query_params,
            header_params=_header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            auth_settings=_auth_settings,
            collection_formats=_collection_formats,
            _host=_host,
            _request_auth=_request_auth
        )




    @validate_call
    def conversation_threads(
        self,
        user_id: Annotated[StrictStr, Field(description="User ID")],
        floor_id: Annotated[StrictStr, Field(description="Floor ID")],
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> ConversationThreads200Response:
        """Get the conversational threads

        ### Conversation Model
        - A **Thread** represents a single conversational context.
        - A **Conversation** is the ordered exchange of messages within a thread.
        - Threads are scoped per user and per floor.
        
        This API retrieves the list of **conversational threads** associated with a specific **user** within a specific **floor**. A **thread** represents a persistent conversation context between the user and the system (agent/assistant)
        
        inside a floor. Each thread maintains its own history and state, allowing users to resume previous conversations without losing context. The API returns **only thread metadata**, not the message content itself. This makes it suitable for:
        * Displaying a conversation list or sidebar
        * Allowing users to select and resume past conversations * Managing conversational memory per floor
        
        ---
        
        ### Key Concepts
        * **Thread**:
        
        A long-lived conversational context tied to a user and a floor * **Floor-scoped memory**: Conversations are isolated per floor; threads from one floor are not visible in another * **User-specific**: Threads are private to the requesting user
        
        ---
        
        **Request Method**
        
         `GET`
        
        ---
        
        **Request Parameters (Query Parameters)**
        
        | Parameter Name | Type | Required | Description |
        | -------------- | ------ | -------- | ---------------------------------------------------------------------------- |
        | `user_id` | String | **Yes** | Unique identifier of the user whose conversation threads are being requested |
        | `floor_id` | String | **Yes** | Identifier of the floor in which the conversations exist |
        
        ---
        
        ### Authorization & Access Rules
        * The caller must be authenticated as the given `user_id`
        * A user can retrieve **only their own threads**
        * Threads are scoped to the provided `floor_id`
        * Threads from other floors or other users are not accessible
        
        ---
        
        ### Response Format `application/json`
        
        ---
        
        ### Response Description The response contains:
        * The `user_id` for which threads were fetched
        * A list of thread metadata objects, sorted by **most recently updated first**
        
        ---
        
        ### Response Structure
        
        ### Top-Level Fields
        
        | Field | Type | Description |
        | --------- | ------ | ------------------------------------------------------------------------- |
        | `user_id` | String | Identifier of the user |
        | `threads` | Array | List of conversation threads belonging to the user in the specified floor |
        
        ---
        
        ### Thread Object (`threads[]`)
        
        | Field | Type | Description |
        | -------------- | ------------------- | ------------------------------------------------- |
        | `thread_id` | String | Unique identifier of the conversation thread |
        | `title` | String | Human-readable title summarizing the conversation |
        | `last_updated` | String (YYYY-MM-DD) | Date when the thread was last updated |
        
        ---
        
        ### Sample
        
        Success Response
        
        ```json { \"user_id\":
        
        \"59\", \"threads\": [ { \"thread_id\": \"55\", \"title\": \"elegant potentially hopelessly ambitious sneak\", \"last_updated\": \"2025-04-26\" }, { \"thread_id\": \"79\", \"title\": \"sans profitable alienated by even overstay miserly practical\", \"last_updated\": \"2025-04-24\" }, { \"thread_id\": \"89\", \"title\": \"although light uh-huh despite instead vol sorrowful\", \"last_updated\": \"2025-02-16\" } ] }
        
        ```
        
        ---
        
        ### Typical Use Cases
        * Show a **list of past conversations** in a chat UI
        * Allow users to **resume a previous thread**
        * Display conversation history grouped by floor
        * Build agent dashboards with user-specific memory
        
        ---
        
        ### Notes
        * This API returns **metadata only**; message history is retrieved using a separate thread-messages API
        * If no threads exist, the `threads` array will be empty * Thread titles may be system-generated or user-editable depending on implementation
        
        ---
        
        ### Common
        
        Error Responses (Examples)
        
        ### Missing Parameters
        
        ```json { \"status\":
        
        \"ERROR\", \"message\": \"user_id and floor_id are required\" }
        
        ```
        
        ### Unauthorised Access
        
        ```json { \"status\": \"ERROR\", \"message\": \"Unauthorized access to conversation threads\" }
        
        ```

        :param user_id: User ID (required)
        :type user_id: str
        :param floor_id: Floor ID (required)
        :type floor_id: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._conversation_threads_serialize(
            user_id=user_id,
            floor_id=floor_id,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "ConversationThreads200Response",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        ).data


    @validate_call
    def conversation_threads_with_http_info(
        self,
        user_id: Annotated[StrictStr, Field(description="User ID")],
        floor_id: Annotated[StrictStr, Field(description="Floor ID")],
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> ApiResponse[ConversationThreads200Response]:
        """Get the conversational threads

        ### Conversation Model
        - A **Thread** represents a single conversational context.
        - A **Conversation** is the ordered exchange of messages within a thread.
        - Threads are scoped per user and per floor.
        
        This API retrieves the list of **conversational threads** associated with a specific **user** within a specific **floor**. A **thread** represents a persistent conversation context between the user and the system (agent/assistant)
        
        inside a floor. Each thread maintains its own history and state, allowing users to resume previous conversations without losing context. The API returns **only thread metadata**, not the message content itself. This makes it suitable for:
        * Displaying a conversation list or sidebar
        * Allowing users to select and resume past conversations * Managing conversational memory per floor
        
        ---
        
        ### Key Concepts
        * **Thread**:
        
        A long-lived conversational context tied to a user and a floor * **Floor-scoped memory**: Conversations are isolated per floor; threads from one floor are not visible in another * **User-specific**: Threads are private to the requesting user
        
        ---
        
        **Request Method**
        
         `GET`
        
        ---
        
        **Request Parameters (Query Parameters)**
        
        | Parameter Name | Type | Required | Description |
        | -------------- | ------ | -------- | ---------------------------------------------------------------------------- |
        | `user_id` | String | **Yes** | Unique identifier of the user whose conversation threads are being requested |
        | `floor_id` | String | **Yes** | Identifier of the floor in which the conversations exist |
        
        ---
        
        ### Authorization & Access Rules
        * The caller must be authenticated as the given `user_id`
        * A user can retrieve **only their own threads**
        * Threads are scoped to the provided `floor_id`
        * Threads from other floors or other users are not accessible
        
        ---
        
        ### Response Format `application/json`
        
        ---
        
        ### Response Description The response contains:
        * The `user_id` for which threads were fetched
        * A list of thread metadata objects, sorted by **most recently updated first**
        
        ---
        
        ### Response Structure
        
        ### Top-Level Fields
        
        | Field | Type | Description |
        | --------- | ------ | ------------------------------------------------------------------------- |
        | `user_id` | String | Identifier of the user |
        | `threads` | Array | List of conversation threads belonging to the user in the specified floor |
        
        ---
        
        ### Thread Object (`threads[]`)
        
        | Field | Type | Description |
        | -------------- | ------------------- | ------------------------------------------------- |
        | `thread_id` | String | Unique identifier of the conversation thread |
        | `title` | String | Human-readable title summarizing the conversation |
        | `last_updated` | String (YYYY-MM-DD) | Date when the thread was last updated |
        
        ---
        
        ### Sample
        
        Success Response
        
        ```json { \"user_id\":
        
        \"59\", \"threads\": [ { \"thread_id\": \"55\", \"title\": \"elegant potentially hopelessly ambitious sneak\", \"last_updated\": \"2025-04-26\" }, { \"thread_id\": \"79\", \"title\": \"sans profitable alienated by even overstay miserly practical\", \"last_updated\": \"2025-04-24\" }, { \"thread_id\": \"89\", \"title\": \"although light uh-huh despite instead vol sorrowful\", \"last_updated\": \"2025-02-16\" } ] }
        
        ```
        
        ---
        
        ### Typical Use Cases
        * Show a **list of past conversations** in a chat UI
        * Allow users to **resume a previous thread**
        * Display conversation history grouped by floor
        * Build agent dashboards with user-specific memory
        
        ---
        
        ### Notes
        * This API returns **metadata only**; message history is retrieved using a separate thread-messages API
        * If no threads exist, the `threads` array will be empty * Thread titles may be system-generated or user-editable depending on implementation
        
        ---
        
        ### Common
        
        Error Responses (Examples)
        
        ### Missing Parameters
        
        ```json { \"status\":
        
        \"ERROR\", \"message\": \"user_id and floor_id are required\" }
        
        ```
        
        ### Unauthorised Access
        
        ```json { \"status\": \"ERROR\", \"message\": \"Unauthorized access to conversation threads\" }
        
        ```

        :param user_id: User ID (required)
        :type user_id: str
        :param floor_id: Floor ID (required)
        :type floor_id: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._conversation_threads_serialize(
            user_id=user_id,
            floor_id=floor_id,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "ConversationThreads200Response",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        )


    @validate_call
    def conversation_threads_without_preload_content(
        self,
        user_id: Annotated[StrictStr, Field(description="User ID")],
        floor_id: Annotated[StrictStr, Field(description="Floor ID")],
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> RESTResponseType:
        """Get the conversational threads

        ### Conversation Model
        - A **Thread** represents a single conversational context.
        - A **Conversation** is the ordered exchange of messages within a thread.
        - Threads are scoped per user and per floor.
        
        This API retrieves the list of **conversational threads** associated with a specific **user** within a specific **floor**. A **thread** represents a persistent conversation context between the user and the system (agent/assistant)
        
        inside a floor. Each thread maintains its own history and state, allowing users to resume previous conversations without losing context. The API returns **only thread metadata**, not the message content itself. This makes it suitable for:
        * Displaying a conversation list or sidebar
        * Allowing users to select and resume past conversations * Managing conversational memory per floor
        
        ---
        
        ### Key Concepts
        * **Thread**:
        
        A long-lived conversational context tied to a user and a floor * **Floor-scoped memory**: Conversations are isolated per floor; threads from one floor are not visible in another * **User-specific**: Threads are private to the requesting user
        
        ---
        
        **Request Method**
        
         `GET`
        
        ---
        
        **Request Parameters (Query Parameters)**
        
        | Parameter Name | Type | Required | Description |
        | -------------- | ------ | -------- | ---------------------------------------------------------------------------- |
        | `user_id` | String | **Yes** | Unique identifier of the user whose conversation threads are being requested |
        | `floor_id` | String | **Yes** | Identifier of the floor in which the conversations exist |
        
        ---
        
        ### Authorization & Access Rules
        * The caller must be authenticated as the given `user_id`
        * A user can retrieve **only their own threads**
        * Threads are scoped to the provided `floor_id`
        * Threads from other floors or other users are not accessible
        
        ---
        
        ### Response Format `application/json`
        
        ---
        
        ### Response Description The response contains:
        * The `user_id` for which threads were fetched
        * A list of thread metadata objects, sorted by **most recently updated first**
        
        ---
        
        ### Response Structure
        
        ### Top-Level Fields
        
        | Field | Type | Description |
        | --------- | ------ | ------------------------------------------------------------------------- |
        | `user_id` | String | Identifier of the user |
        | `threads` | Array | List of conversation threads belonging to the user in the specified floor |
        
        ---
        
        ### Thread Object (`threads[]`)
        
        | Field | Type | Description |
        | -------------- | ------------------- | ------------------------------------------------- |
        | `thread_id` | String | Unique identifier of the conversation thread |
        | `title` | String | Human-readable title summarizing the conversation |
        | `last_updated` | String (YYYY-MM-DD) | Date when the thread was last updated |
        
        ---
        
        ### Sample
        
        Success Response
        
        ```json { \"user_id\":
        
        \"59\", \"threads\": [ { \"thread_id\": \"55\", \"title\": \"elegant potentially hopelessly ambitious sneak\", \"last_updated\": \"2025-04-26\" }, { \"thread_id\": \"79\", \"title\": \"sans profitable alienated by even overstay miserly practical\", \"last_updated\": \"2025-04-24\" }, { \"thread_id\": \"89\", \"title\": \"although light uh-huh despite instead vol sorrowful\", \"last_updated\": \"2025-02-16\" } ] }
        
        ```
        
        ---
        
        ### Typical Use Cases
        * Show a **list of past conversations** in a chat UI
        * Allow users to **resume a previous thread**
        * Display conversation history grouped by floor
        * Build agent dashboards with user-specific memory
        
        ---
        
        ### Notes
        * This API returns **metadata only**; message history is retrieved using a separate thread-messages API
        * If no threads exist, the `threads` array will be empty * Thread titles may be system-generated or user-editable depending on implementation
        
        ---
        
        ### Common
        
        Error Responses (Examples)
        
        ### Missing Parameters
        
        ```json { \"status\":
        
        \"ERROR\", \"message\": \"user_id and floor_id are required\" }
        
        ```
        
        ### Unauthorised Access
        
        ```json { \"status\": \"ERROR\", \"message\": \"Unauthorized access to conversation threads\" }
        
        ```

        :param user_id: User ID (required)
        :type user_id: str
        :param floor_id: Floor ID (required)
        :type floor_id: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._conversation_threads_serialize(
            user_id=user_id,
            floor_id=floor_id,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "ConversationThreads200Response",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        return response_data.response


    def _conversation_threads_serialize(
        self,
        user_id,
        floor_id,
        _request_auth,
        _content_type,
        _headers,
        _host_index,
    ) -> RequestSerialized:

        _host = None

        _collection_formats: Dict[str, str] = {
        }

        _path_params: Dict[str, str] = {}
        _query_params: List[Tuple[str, str]] = []
        _header_params: Dict[str, Optional[str]] = _headers or {}
        _form_params: List[Tuple[str, str]] = []
        _files: Dict[
            str, Union[str, bytes, List[str], List[bytes], List[Tuple[str, bytes]]]
        ] = {}
        _body_params: Optional[bytes] = None

        # process the path parameters
        # process the query parameters
        if user_id is not None:
            
            _query_params.append(('user_id', user_id))
            
        if floor_id is not None:
            
            _query_params.append(('floor_id', floor_id))
            
        # process the header parameters
        # process the form parameters
        # process the body parameter


        # set the HTTP header `Accept`
        if 'Accept' not in _header_params:
            _header_params['Accept'] = self.api_client.select_header_accept(
                [
                    'application/json'
                ]
            )


        # authentication setting
        _auth_settings: List[str] = [
            'bearer'
        ]

        return self.api_client.param_serialize(
            method='GET',
            resource_path='/agent/memory/threads',
            path_params=_path_params,
            query_params=_query_params,
            header_params=_header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            auth_settings=_auth_settings,
            collection_formats=_collection_formats,
            _host=_host,
            _request_auth=_request_auth
        )




    @validate_call
    def get_conversations(
        self,
        user_id: Optional[StrictStr] = None,
        thread_id: Optional[StrictStr] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> GetConversations200Response:
        """Conversations

        This API returns the **full conversation history** for a specific **thread** belonging to a user within a floor. A **thread** represents a persistent conversation session. Each item in the returned `conversation` array contains:
        * The **user request payload** (user query + context)
        * The **assistant response payload** (full LLM completion object) * The **retrieval trace** (metadata of posts fetched/used for the answer, including scores and identifiers) This endpoint is intended for **developers** building custom conversational UIs and tooling that require:
        * Full conversation replay
        * Debug visibility into the assistant output object (`choices`, model info, etc.) * RAG explainability via `fetch_multiple_posts.results[]`
        
        ---
        
        **Request Method**
        
         `GET`
        
        ---
        
        ### Query Parameters
        
        | Parameter | Type | Required | Description |
        | ----------- | ------ | -------- | --------------------------------------------------------------------------- |
        | `user_id` | String | **Yes** | Owner of the conversation thread. The thread must belong to this user. |
        | `floor_id` | String | **Yes** | Floor identifier in which the thread exists. Threads are scoped to a floor. |
        | `thread_id` | String | **Yes** | Thread identifier whose conversations should be returned. |
        
        ---
        
        ### Authorization & Access Rules
        * The caller must be authenticated as the given `user_id` (or have equivalent developer/system permission).
        * A user can access **only their own threads**.
        * Cross-user or cross-floor access must be rejected.
        
        ---
        
        ### Response Format `application/json`
        
        ---
        
        ### Response Description Returns the thread-level conversation payload:
        * `user_id`: the user who owns the thread
        * `thread_id`: the requested thread * `conversation`: ordered list of conversation entries (each entry = user object + assistant object)
        
        ---
        
        ### Response Schema
        
        ### Top-Level Fields
        
        | Field | Type | Description |
        | -------------- | ------ | ---------------------------- |
        | `user_id` | String | Owner of the thread |
        | `thread_id` | String | Thread identifier |
        | `conversation` | Array | List of conversation entries |
        
        ---
        
        ### `conversation[]` Entry Structure Each entry contains two objects:
        
        `user` and `assistant`.
        
        ---
        
        ### `user` Object
        
        | Field | Type | Description |
        | ------------------ | ------ | ------------------------------------------------------------------- |
        | `context` | Object | Context used when processing the query (floor metadata, mode, etc.) |
        | `user_query` | String | The user’s query message |
        | `user_id` | String | User identifier (should match top-level `user_id`) |
        | `user_thread` | String | Thread identifier (should match top-level `thread_id`) |
        | `recorded_content` | String | Persisted user content (often same as `user_query`) |
        
        #### `user.context` | Field | Type | Description |
        | ---------------- | ------ | ---------------------------------------------- |
        | `floor_id` | String | Floor UID/slug where the conversation occurred |
        | `title` | String | Floor title at the time of the query |
        | `fid` | String | Immutable internal floor ID |
        | `floor_category` | String | Floor category identifier |
        | `floor_mode` | String | Floor mode indicator (example: `\"1\"`) |
        
        ---
        
        ### `assistant` Object
        
        This contains the **full completion response** plus retrieval details.
        
        | Field | Type | Description |
        | ---------------------- | ------ | --------------------------------------------------- |
        | `id` | String | Completion id (e.g., `chatcmpl-*`) |
        | `object` | String | Response type (e.g., `chat.completion`) |
        | `created` | Number | Timestamp when response was created (epoch seconds) |
        | `floor_mode` | String | Floor mode applied for generation |
        | `model` | String | Model identifier used |
        | `choices` | Array | Generated outputs and metadata |
        | `fetch_multiple_posts` | Object | Retrieval trace (if retrieval was performed) |
        | `content_type` | String | Retrieved content type (e.g., `post`) |
        
        ---
        
        ### `assistant.choices[]`
        
        | Field | Type | Description |
        | ------------------ | ------ | -------------------------------------------------------------------------- |
        | `index` | Number | Choice index |
        | `message` | Object | Assistant message content |
        | `finish_reason` | String | Why generation stopped (`stop`, `length`, etc.) |
        | `ai_model_details` | Object | Model runtime parameters (temperature, top_p, max_tokens, penalties, etc.) |
        | `prompt_details` | Object | Prompt configuration used (system prompt, system_prompt_id, etc.) |
        
        > **Note:** `prompt_details.system_prompt` may be large and is returned as-is for developer inspection.
        
        ---
        
        ### `assistant.fetch_multiple_posts` Describes the retrieval operation performed for the query.
        
        | Field | Type | Description |
        | -------------- | ------ | -------------------------------------- |
        | `content_type` | String | Type of retrieved content (`post`) |
        | `query` | String | Query used for retrieval |
        | `status` | String | Retrieval status (`success`, `failed`) |
        | `message` | String | Retrieval message |
        | `results` | Array | List of matched posts and metadata |
        
        ---
        
        ### `assistant.fetch_multiple_posts.results[]`
        
        | Field | Type | Description |
        | ------------ | ------ | ----------------------------------------------------------------- |
        | `from_floor` | String | Indicates source floor relation (e.g., same floor / linked floor) |
        | `content` | String | Raw JSON string of the matched post metadata/content |
        | `author` | String | Author id of the matched post |
        | `block_type` | Number | Block type of the matched post |
        | `pid` | String | Post/document id |
        | `bid` | String | Block id containing the post |
        | `fid` | String | Floor internal id where the post belongs |
        | `score` | Number | Similarity score |
        | `match_type` | String | Match type (`text`, etc.) |
        
        ---
        
        ### Sample
        
        Success Response Your provided payload is the canonical example. It includes:
        * the user query and floor context
        * the full assistant completion object * the full retrieval results with post metadata * the response shown covers a few important items.
        
        ---
        
        ### Common
        
        Error Responses
        
        ### Missing Parameters
        
        ```json { \"status\":
        
        \"ERROR\", \"message\": \"user_id, floor_id, and thread_id are required\" }
        
        ```
        
        ### Unauthorized Access
        
        ```json { \"status\": \"ERROR\", \"message\": \"Unauthorized access to thread\" }
        
        ```
        
        ### Thread Not Found
        
        ```json { \"status\": \"ERROR\", \"message\": \"Thread not found\" }
        
        ```
        
        ---
        
        ### Developer
        
        Notes (Important)
        * The `content` field inside retrieval results is a **stringified JSON**. Developers may parse it to access fields such as `post_title`, `post_details`, etc.
        * `choices` may contain multiple outputs depending on backend configuration. * This API returns a “full debug payload” suitable for developers. If you later create a lightweight UI endpoint, it should strip execution details and return only `user_query`, `assistant.content`, and curated post references.

        :param user_id: 
        :type user_id: str
        :param thread_id: 
        :type thread_id: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._get_conversations_serialize(
            user_id=user_id,
            thread_id=thread_id,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "GetConversations200Response",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        ).data


    @validate_call
    def get_conversations_with_http_info(
        self,
        user_id: Optional[StrictStr] = None,
        thread_id: Optional[StrictStr] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> ApiResponse[GetConversations200Response]:
        """Conversations

        This API returns the **full conversation history** for a specific **thread** belonging to a user within a floor. A **thread** represents a persistent conversation session. Each item in the returned `conversation` array contains:
        * The **user request payload** (user query + context)
        * The **assistant response payload** (full LLM completion object) * The **retrieval trace** (metadata of posts fetched/used for the answer, including scores and identifiers) This endpoint is intended for **developers** building custom conversational UIs and tooling that require:
        * Full conversation replay
        * Debug visibility into the assistant output object (`choices`, model info, etc.) * RAG explainability via `fetch_multiple_posts.results[]`
        
        ---
        
        **Request Method**
        
         `GET`
        
        ---
        
        ### Query Parameters
        
        | Parameter | Type | Required | Description |
        | ----------- | ------ | -------- | --------------------------------------------------------------------------- |
        | `user_id` | String | **Yes** | Owner of the conversation thread. The thread must belong to this user. |
        | `floor_id` | String | **Yes** | Floor identifier in which the thread exists. Threads are scoped to a floor. |
        | `thread_id` | String | **Yes** | Thread identifier whose conversations should be returned. |
        
        ---
        
        ### Authorization & Access Rules
        * The caller must be authenticated as the given `user_id` (or have equivalent developer/system permission).
        * A user can access **only their own threads**.
        * Cross-user or cross-floor access must be rejected.
        
        ---
        
        ### Response Format `application/json`
        
        ---
        
        ### Response Description Returns the thread-level conversation payload:
        * `user_id`: the user who owns the thread
        * `thread_id`: the requested thread * `conversation`: ordered list of conversation entries (each entry = user object + assistant object)
        
        ---
        
        ### Response Schema
        
        ### Top-Level Fields
        
        | Field | Type | Description |
        | -------------- | ------ | ---------------------------- |
        | `user_id` | String | Owner of the thread |
        | `thread_id` | String | Thread identifier |
        | `conversation` | Array | List of conversation entries |
        
        ---
        
        ### `conversation[]` Entry Structure Each entry contains two objects:
        
        `user` and `assistant`.
        
        ---
        
        ### `user` Object
        
        | Field | Type | Description |
        | ------------------ | ------ | ------------------------------------------------------------------- |
        | `context` | Object | Context used when processing the query (floor metadata, mode, etc.) |
        | `user_query` | String | The user’s query message |
        | `user_id` | String | User identifier (should match top-level `user_id`) |
        | `user_thread` | String | Thread identifier (should match top-level `thread_id`) |
        | `recorded_content` | String | Persisted user content (often same as `user_query`) |
        
        #### `user.context` | Field | Type | Description |
        | ---------------- | ------ | ---------------------------------------------- |
        | `floor_id` | String | Floor UID/slug where the conversation occurred |
        | `title` | String | Floor title at the time of the query |
        | `fid` | String | Immutable internal floor ID |
        | `floor_category` | String | Floor category identifier |
        | `floor_mode` | String | Floor mode indicator (example: `\"1\"`) |
        
        ---
        
        ### `assistant` Object
        
        This contains the **full completion response** plus retrieval details.
        
        | Field | Type | Description |
        | ---------------------- | ------ | --------------------------------------------------- |
        | `id` | String | Completion id (e.g., `chatcmpl-*`) |
        | `object` | String | Response type (e.g., `chat.completion`) |
        | `created` | Number | Timestamp when response was created (epoch seconds) |
        | `floor_mode` | String | Floor mode applied for generation |
        | `model` | String | Model identifier used |
        | `choices` | Array | Generated outputs and metadata |
        | `fetch_multiple_posts` | Object | Retrieval trace (if retrieval was performed) |
        | `content_type` | String | Retrieved content type (e.g., `post`) |
        
        ---
        
        ### `assistant.choices[]`
        
        | Field | Type | Description |
        | ------------------ | ------ | -------------------------------------------------------------------------- |
        | `index` | Number | Choice index |
        | `message` | Object | Assistant message content |
        | `finish_reason` | String | Why generation stopped (`stop`, `length`, etc.) |
        | `ai_model_details` | Object | Model runtime parameters (temperature, top_p, max_tokens, penalties, etc.) |
        | `prompt_details` | Object | Prompt configuration used (system prompt, system_prompt_id, etc.) |
        
        > **Note:** `prompt_details.system_prompt` may be large and is returned as-is for developer inspection.
        
        ---
        
        ### `assistant.fetch_multiple_posts` Describes the retrieval operation performed for the query.
        
        | Field | Type | Description |
        | -------------- | ------ | -------------------------------------- |
        | `content_type` | String | Type of retrieved content (`post`) |
        | `query` | String | Query used for retrieval |
        | `status` | String | Retrieval status (`success`, `failed`) |
        | `message` | String | Retrieval message |
        | `results` | Array | List of matched posts and metadata |
        
        ---
        
        ### `assistant.fetch_multiple_posts.results[]`
        
        | Field | Type | Description |
        | ------------ | ------ | ----------------------------------------------------------------- |
        | `from_floor` | String | Indicates source floor relation (e.g., same floor / linked floor) |
        | `content` | String | Raw JSON string of the matched post metadata/content |
        | `author` | String | Author id of the matched post |
        | `block_type` | Number | Block type of the matched post |
        | `pid` | String | Post/document id |
        | `bid` | String | Block id containing the post |
        | `fid` | String | Floor internal id where the post belongs |
        | `score` | Number | Similarity score |
        | `match_type` | String | Match type (`text`, etc.) |
        
        ---
        
        ### Sample
        
        Success Response Your provided payload is the canonical example. It includes:
        * the user query and floor context
        * the full assistant completion object * the full retrieval results with post metadata * the response shown covers a few important items.
        
        ---
        
        ### Common
        
        Error Responses
        
        ### Missing Parameters
        
        ```json { \"status\":
        
        \"ERROR\", \"message\": \"user_id, floor_id, and thread_id are required\" }
        
        ```
        
        ### Unauthorized Access
        
        ```json { \"status\": \"ERROR\", \"message\": \"Unauthorized access to thread\" }
        
        ```
        
        ### Thread Not Found
        
        ```json { \"status\": \"ERROR\", \"message\": \"Thread not found\" }
        
        ```
        
        ---
        
        ### Developer
        
        Notes (Important)
        * The `content` field inside retrieval results is a **stringified JSON**. Developers may parse it to access fields such as `post_title`, `post_details`, etc.
        * `choices` may contain multiple outputs depending on backend configuration. * This API returns a “full debug payload” suitable for developers. If you later create a lightweight UI endpoint, it should strip execution details and return only `user_query`, `assistant.content`, and curated post references.

        :param user_id: 
        :type user_id: str
        :param thread_id: 
        :type thread_id: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._get_conversations_serialize(
            user_id=user_id,
            thread_id=thread_id,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "GetConversations200Response",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        )


    @validate_call
    def get_conversations_without_preload_content(
        self,
        user_id: Optional[StrictStr] = None,
        thread_id: Optional[StrictStr] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> RESTResponseType:
        """Conversations

        This API returns the **full conversation history** for a specific **thread** belonging to a user within a floor. A **thread** represents a persistent conversation session. Each item in the returned `conversation` array contains:
        * The **user request payload** (user query + context)
        * The **assistant response payload** (full LLM completion object) * The **retrieval trace** (metadata of posts fetched/used for the answer, including scores and identifiers) This endpoint is intended for **developers** building custom conversational UIs and tooling that require:
        * Full conversation replay
        * Debug visibility into the assistant output object (`choices`, model info, etc.) * RAG explainability via `fetch_multiple_posts.results[]`
        
        ---
        
        **Request Method**
        
         `GET`
        
        ---
        
        ### Query Parameters
        
        | Parameter | Type | Required | Description |
        | ----------- | ------ | -------- | --------------------------------------------------------------------------- |
        | `user_id` | String | **Yes** | Owner of the conversation thread. The thread must belong to this user. |
        | `floor_id` | String | **Yes** | Floor identifier in which the thread exists. Threads are scoped to a floor. |
        | `thread_id` | String | **Yes** | Thread identifier whose conversations should be returned. |
        
        ---
        
        ### Authorization & Access Rules
        * The caller must be authenticated as the given `user_id` (or have equivalent developer/system permission).
        * A user can access **only their own threads**.
        * Cross-user or cross-floor access must be rejected.
        
        ---
        
        ### Response Format `application/json`
        
        ---
        
        ### Response Description Returns the thread-level conversation payload:
        * `user_id`: the user who owns the thread
        * `thread_id`: the requested thread * `conversation`: ordered list of conversation entries (each entry = user object + assistant object)
        
        ---
        
        ### Response Schema
        
        ### Top-Level Fields
        
        | Field | Type | Description |
        | -------------- | ------ | ---------------------------- |
        | `user_id` | String | Owner of the thread |
        | `thread_id` | String | Thread identifier |
        | `conversation` | Array | List of conversation entries |
        
        ---
        
        ### `conversation[]` Entry Structure Each entry contains two objects:
        
        `user` and `assistant`.
        
        ---
        
        ### `user` Object
        
        | Field | Type | Description |
        | ------------------ | ------ | ------------------------------------------------------------------- |
        | `context` | Object | Context used when processing the query (floor metadata, mode, etc.) |
        | `user_query` | String | The user’s query message |
        | `user_id` | String | User identifier (should match top-level `user_id`) |
        | `user_thread` | String | Thread identifier (should match top-level `thread_id`) |
        | `recorded_content` | String | Persisted user content (often same as `user_query`) |
        
        #### `user.context` | Field | Type | Description |
        | ---------------- | ------ | ---------------------------------------------- |
        | `floor_id` | String | Floor UID/slug where the conversation occurred |
        | `title` | String | Floor title at the time of the query |
        | `fid` | String | Immutable internal floor ID |
        | `floor_category` | String | Floor category identifier |
        | `floor_mode` | String | Floor mode indicator (example: `\"1\"`) |
        
        ---
        
        ### `assistant` Object
        
        This contains the **full completion response** plus retrieval details.
        
        | Field | Type | Description |
        | ---------------------- | ------ | --------------------------------------------------- |
        | `id` | String | Completion id (e.g., `chatcmpl-*`) |
        | `object` | String | Response type (e.g., `chat.completion`) |
        | `created` | Number | Timestamp when response was created (epoch seconds) |
        | `floor_mode` | String | Floor mode applied for generation |
        | `model` | String | Model identifier used |
        | `choices` | Array | Generated outputs and metadata |
        | `fetch_multiple_posts` | Object | Retrieval trace (if retrieval was performed) |
        | `content_type` | String | Retrieved content type (e.g., `post`) |
        
        ---
        
        ### `assistant.choices[]`
        
        | Field | Type | Description |
        | ------------------ | ------ | -------------------------------------------------------------------------- |
        | `index` | Number | Choice index |
        | `message` | Object | Assistant message content |
        | `finish_reason` | String | Why generation stopped (`stop`, `length`, etc.) |
        | `ai_model_details` | Object | Model runtime parameters (temperature, top_p, max_tokens, penalties, etc.) |
        | `prompt_details` | Object | Prompt configuration used (system prompt, system_prompt_id, etc.) |
        
        > **Note:** `prompt_details.system_prompt` may be large and is returned as-is for developer inspection.
        
        ---
        
        ### `assistant.fetch_multiple_posts` Describes the retrieval operation performed for the query.
        
        | Field | Type | Description |
        | -------------- | ------ | -------------------------------------- |
        | `content_type` | String | Type of retrieved content (`post`) |
        | `query` | String | Query used for retrieval |
        | `status` | String | Retrieval status (`success`, `failed`) |
        | `message` | String | Retrieval message |
        | `results` | Array | List of matched posts and metadata |
        
        ---
        
        ### `assistant.fetch_multiple_posts.results[]`
        
        | Field | Type | Description |
        | ------------ | ------ | ----------------------------------------------------------------- |
        | `from_floor` | String | Indicates source floor relation (e.g., same floor / linked floor) |
        | `content` | String | Raw JSON string of the matched post metadata/content |
        | `author` | String | Author id of the matched post |
        | `block_type` | Number | Block type of the matched post |
        | `pid` | String | Post/document id |
        | `bid` | String | Block id containing the post |
        | `fid` | String | Floor internal id where the post belongs |
        | `score` | Number | Similarity score |
        | `match_type` | String | Match type (`text`, etc.) |
        
        ---
        
        ### Sample
        
        Success Response Your provided payload is the canonical example. It includes:
        * the user query and floor context
        * the full assistant completion object * the full retrieval results with post metadata * the response shown covers a few important items.
        
        ---
        
        ### Common
        
        Error Responses
        
        ### Missing Parameters
        
        ```json { \"status\":
        
        \"ERROR\", \"message\": \"user_id, floor_id, and thread_id are required\" }
        
        ```
        
        ### Unauthorized Access
        
        ```json { \"status\": \"ERROR\", \"message\": \"Unauthorized access to thread\" }
        
        ```
        
        ### Thread Not Found
        
        ```json { \"status\": \"ERROR\", \"message\": \"Thread not found\" }
        
        ```
        
        ---
        
        ### Developer
        
        Notes (Important)
        * The `content` field inside retrieval results is a **stringified JSON**. Developers may parse it to access fields such as `post_title`, `post_details`, etc.
        * `choices` may contain multiple outputs depending on backend configuration. * This API returns a “full debug payload” suitable for developers. If you later create a lightweight UI endpoint, it should strip execution details and return only `user_query`, `assistant.content`, and curated post references.

        :param user_id: 
        :type user_id: str
        :param thread_id: 
        :type thread_id: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._get_conversations_serialize(
            user_id=user_id,
            thread_id=thread_id,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "GetConversations200Response",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        return response_data.response


    def _get_conversations_serialize(
        self,
        user_id,
        thread_id,
        _request_auth,
        _content_type,
        _headers,
        _host_index,
    ) -> RequestSerialized:

        _host = None

        _collection_formats: Dict[str, str] = {
        }

        _path_params: Dict[str, str] = {}
        _query_params: List[Tuple[str, str]] = []
        _header_params: Dict[str, Optional[str]] = _headers or {}
        _form_params: List[Tuple[str, str]] = []
        _files: Dict[
            str, Union[str, bytes, List[str], List[bytes], List[Tuple[str, bytes]]]
        ] = {}
        _body_params: Optional[bytes] = None

        # process the path parameters
        # process the query parameters
        if user_id is not None:
            
            _query_params.append(('user_id', user_id))
            
        if thread_id is not None:
            
            _query_params.append(('thread_id', thread_id))
            
        # process the header parameters
        # process the form parameters
        # process the body parameter


        # set the HTTP header `Accept`
        if 'Accept' not in _header_params:
            _header_params['Accept'] = self.api_client.select_header_accept(
                [
                    'application/json'
                ]
            )


        # authentication setting
        _auth_settings: List[str] = [
            'bearer'
        ]

        return self.api_client.param_serialize(
            method='GET',
            resource_path='/agent/memory/conversations',
            path_params=_path_params,
            query_params=_query_params,
            header_params=_header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            auth_settings=_auth_settings,
            collection_formats=_collection_formats,
            _host=_host,
            _request_auth=_request_auth
        )




    @validate_call
    def make_floor_private(
        self,
        floor_id: StrictStr,
        user_id: Annotated[StrictStr, Field(description="User ID")],
        app_id: Annotated[StrictStr, Field(description="App ID")],
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> GetFloorInformation200Response:
        """Make floor Private

        This API changes a floor’s visibility to **PRIVATE**. It is used when a floor owner wants to **restrict access** to a floor that is currently public. After the update, the floor becomes private and is no longer accessible to non-authorized users (based on your platform’s access rules). This endpoint is **state-changing**:
        * If the floor is **PUBLIC**, it will be converted to **PRIVATE**
        * If the floor is already **PRIVATE**, the API returns success (idempotent) or an “already private” response depending on implementation This API is commonly used in:
        * Floor settings → “Privacy” toggle
        * Developer-managed pod workflows (app_id context) * Admin tools (if applicable)
        
        ---
        
        **Request Method**
        
         `POST`
        
        ---
        
        **Content-Type**
        
         `application/x-www-form-urlencoded` (or `multipart/form-data` if your system uses form-data)
        
        *(Document whichever you actually accept; below assumes standard form fields.)*
        
        ---
        
        **Request Parameters (Form Fields)**
        
        | Field | Type | Required | Description |
        | ---------- | ------ | -------- | -------------------------------------------------------------------- |
        | `user_id` | String | **Yes** | User requesting the change. Must be the **owner** of the floor. |
        | `floor_id` | String | **Yes** | Public identifier of the floor to update. |
        | `app_id` | String | No | Calling application identifier (used for developer/pod integration). |
        
        ---
        
        ### Authorization Rules (Critical)
        * The caller must be authenticated as `user_id`
        * **Only the floor owner** can change floor visibility * If the user is not the owner, the request must be rejected
        
        ---
        
        ### Behavior Rules
        * Converts visibility from **PUBLIC → PRIVATE**
        * Does not modify floor content or blocks * Access enforcement for private floors is applied immediately after the change **Idempotency**
        * Calling this API multiple times should not cause repeated changes
        * If already private, the API should either:
        * return success with a message like `\"already private\"`, or
        * return a specific error/status indicating no-op
        
        ---
        
        ### Response Format `application/json`
        
        ---
        
        ### Sample
        
        Success Response *(Example — adjust to match your actual response format)*
        
        ```json { \"status\":
        
        \"SUCCESS\", \"floor_id\": \"my_floor\", \"visibility\": \"PRIVATE\", \"message\": \"Floor is now private\" }
        
        ```
        
        ---
        
        ### Sample No-Op Response (Already Private)
        
        ```json { \"status\": \"SUCCESS\", \"floor_id\": \"my_floor\", \"visibility\": \"PRIVATE\", \"message\": \"Floor is already private\" }
        
        ```
        
        ---
        
        ### Error Responses (Examples)
        
        ### Not Authorized (Not Owner)
        
        ```json { \"status\": \"ERROR\", \"message\": \"Only the floor owner can change floor visibility\" }
        
        ```
        
        ### Floor Not Found
        
        ```json { \"status\": \"ERROR\", \"message\": \"Floor not found\" }
        
        ```
        
        ### Invalid Request
        
        ```json { \"status\": \"ERROR\", \"message\": \"user_id and floor_id are required\" }
        
        ```
        
        ---
        
        ### Notes
        * This API is intended to control floor visibility only; membership/invite rules (for private floors)
        
        are handled elsewhere. * `app_id` is provided for developer/pod applications and is optional unless enforced by your app model. * If you support floor types like `POD`, document whether pods are allowed to be private or not (some platforms restrict this).

        :param floor_id:  (required)
        :type floor_id: str
        :param user_id: User ID (required)
        :type user_id: str
        :param app_id: App ID (required)
        :type app_id: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._make_floor_private_serialize(
            floor_id=floor_id,
            user_id=user_id,
            app_id=app_id,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "GetFloorInformation200Response",
            '400': "EditFloor400Response",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        ).data


    @validate_call
    def make_floor_private_with_http_info(
        self,
        floor_id: StrictStr,
        user_id: Annotated[StrictStr, Field(description="User ID")],
        app_id: Annotated[StrictStr, Field(description="App ID")],
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> ApiResponse[GetFloorInformation200Response]:
        """Make floor Private

        This API changes a floor’s visibility to **PRIVATE**. It is used when a floor owner wants to **restrict access** to a floor that is currently public. After the update, the floor becomes private and is no longer accessible to non-authorized users (based on your platform’s access rules). This endpoint is **state-changing**:
        * If the floor is **PUBLIC**, it will be converted to **PRIVATE**
        * If the floor is already **PRIVATE**, the API returns success (idempotent) or an “already private” response depending on implementation This API is commonly used in:
        * Floor settings → “Privacy” toggle
        * Developer-managed pod workflows (app_id context) * Admin tools (if applicable)
        
        ---
        
        **Request Method**
        
         `POST`
        
        ---
        
        **Content-Type**
        
         `application/x-www-form-urlencoded` (or `multipart/form-data` if your system uses form-data)
        
        *(Document whichever you actually accept; below assumes standard form fields.)*
        
        ---
        
        **Request Parameters (Form Fields)**
        
        | Field | Type | Required | Description |
        | ---------- | ------ | -------- | -------------------------------------------------------------------- |
        | `user_id` | String | **Yes** | User requesting the change. Must be the **owner** of the floor. |
        | `floor_id` | String | **Yes** | Public identifier of the floor to update. |
        | `app_id` | String | No | Calling application identifier (used for developer/pod integration). |
        
        ---
        
        ### Authorization Rules (Critical)
        * The caller must be authenticated as `user_id`
        * **Only the floor owner** can change floor visibility * If the user is not the owner, the request must be rejected
        
        ---
        
        ### Behavior Rules
        * Converts visibility from **PUBLIC → PRIVATE**
        * Does not modify floor content or blocks * Access enforcement for private floors is applied immediately after the change **Idempotency**
        * Calling this API multiple times should not cause repeated changes
        * If already private, the API should either:
        * return success with a message like `\"already private\"`, or
        * return a specific error/status indicating no-op
        
        ---
        
        ### Response Format `application/json`
        
        ---
        
        ### Sample
        
        Success Response *(Example — adjust to match your actual response format)*
        
        ```json { \"status\":
        
        \"SUCCESS\", \"floor_id\": \"my_floor\", \"visibility\": \"PRIVATE\", \"message\": \"Floor is now private\" }
        
        ```
        
        ---
        
        ### Sample No-Op Response (Already Private)
        
        ```json { \"status\": \"SUCCESS\", \"floor_id\": \"my_floor\", \"visibility\": \"PRIVATE\", \"message\": \"Floor is already private\" }
        
        ```
        
        ---
        
        ### Error Responses (Examples)
        
        ### Not Authorized (Not Owner)
        
        ```json { \"status\": \"ERROR\", \"message\": \"Only the floor owner can change floor visibility\" }
        
        ```
        
        ### Floor Not Found
        
        ```json { \"status\": \"ERROR\", \"message\": \"Floor not found\" }
        
        ```
        
        ### Invalid Request
        
        ```json { \"status\": \"ERROR\", \"message\": \"user_id and floor_id are required\" }
        
        ```
        
        ---
        
        ### Notes
        * This API is intended to control floor visibility only; membership/invite rules (for private floors)
        
        are handled elsewhere. * `app_id` is provided for developer/pod applications and is optional unless enforced by your app model. * If you support floor types like `POD`, document whether pods are allowed to be private or not (some platforms restrict this).

        :param floor_id:  (required)
        :type floor_id: str
        :param user_id: User ID (required)
        :type user_id: str
        :param app_id: App ID (required)
        :type app_id: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._make_floor_private_serialize(
            floor_id=floor_id,
            user_id=user_id,
            app_id=app_id,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "GetFloorInformation200Response",
            '400': "EditFloor400Response",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        )


    @validate_call
    def make_floor_private_without_preload_content(
        self,
        floor_id: StrictStr,
        user_id: Annotated[StrictStr, Field(description="User ID")],
        app_id: Annotated[StrictStr, Field(description="App ID")],
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> RESTResponseType:
        """Make floor Private

        This API changes a floor’s visibility to **PRIVATE**. It is used when a floor owner wants to **restrict access** to a floor that is currently public. After the update, the floor becomes private and is no longer accessible to non-authorized users (based on your platform’s access rules). This endpoint is **state-changing**:
        * If the floor is **PUBLIC**, it will be converted to **PRIVATE**
        * If the floor is already **PRIVATE**, the API returns success (idempotent) or an “already private” response depending on implementation This API is commonly used in:
        * Floor settings → “Privacy” toggle
        * Developer-managed pod workflows (app_id context) * Admin tools (if applicable)
        
        ---
        
        **Request Method**
        
         `POST`
        
        ---
        
        **Content-Type**
        
         `application/x-www-form-urlencoded` (or `multipart/form-data` if your system uses form-data)
        
        *(Document whichever you actually accept; below assumes standard form fields.)*
        
        ---
        
        **Request Parameters (Form Fields)**
        
        | Field | Type | Required | Description |
        | ---------- | ------ | -------- | -------------------------------------------------------------------- |
        | `user_id` | String | **Yes** | User requesting the change. Must be the **owner** of the floor. |
        | `floor_id` | String | **Yes** | Public identifier of the floor to update. |
        | `app_id` | String | No | Calling application identifier (used for developer/pod integration). |
        
        ---
        
        ### Authorization Rules (Critical)
        * The caller must be authenticated as `user_id`
        * **Only the floor owner** can change floor visibility * If the user is not the owner, the request must be rejected
        
        ---
        
        ### Behavior Rules
        * Converts visibility from **PUBLIC → PRIVATE**
        * Does not modify floor content or blocks * Access enforcement for private floors is applied immediately after the change **Idempotency**
        * Calling this API multiple times should not cause repeated changes
        * If already private, the API should either:
        * return success with a message like `\"already private\"`, or
        * return a specific error/status indicating no-op
        
        ---
        
        ### Response Format `application/json`
        
        ---
        
        ### Sample
        
        Success Response *(Example — adjust to match your actual response format)*
        
        ```json { \"status\":
        
        \"SUCCESS\", \"floor_id\": \"my_floor\", \"visibility\": \"PRIVATE\", \"message\": \"Floor is now private\" }
        
        ```
        
        ---
        
        ### Sample No-Op Response (Already Private)
        
        ```json { \"status\": \"SUCCESS\", \"floor_id\": \"my_floor\", \"visibility\": \"PRIVATE\", \"message\": \"Floor is already private\" }
        
        ```
        
        ---
        
        ### Error Responses (Examples)
        
        ### Not Authorized (Not Owner)
        
        ```json { \"status\": \"ERROR\", \"message\": \"Only the floor owner can change floor visibility\" }
        
        ```
        
        ### Floor Not Found
        
        ```json { \"status\": \"ERROR\", \"message\": \"Floor not found\" }
        
        ```
        
        ### Invalid Request
        
        ```json { \"status\": \"ERROR\", \"message\": \"user_id and floor_id are required\" }
        
        ```
        
        ---
        
        ### Notes
        * This API is intended to control floor visibility only; membership/invite rules (for private floors)
        
        are handled elsewhere. * `app_id` is provided for developer/pod applications and is optional unless enforced by your app model. * If you support floor types like `POD`, document whether pods are allowed to be private or not (some platforms restrict this).

        :param floor_id:  (required)
        :type floor_id: str
        :param user_id: User ID (required)
        :type user_id: str
        :param app_id: App ID (required)
        :type app_id: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._make_floor_private_serialize(
            floor_id=floor_id,
            user_id=user_id,
            app_id=app_id,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "GetFloorInformation200Response",
            '400': "EditFloor400Response",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        return response_data.response


    def _make_floor_private_serialize(
        self,
        floor_id,
        user_id,
        app_id,
        _request_auth,
        _content_type,
        _headers,
        _host_index,
    ) -> RequestSerialized:

        _host = None

        _collection_formats: Dict[str, str] = {
        }

        _path_params: Dict[str, str] = {}
        _query_params: List[Tuple[str, str]] = []
        _header_params: Dict[str, Optional[str]] = _headers or {}
        _form_params: List[Tuple[str, str]] = []
        _files: Dict[
            str, Union[str, bytes, List[str], List[bytes], List[Tuple[str, bytes]]]
        ] = {}
        _body_params: Optional[bytes] = None

        # process the path parameters
        if floor_id is not None:
            _path_params['floor_id'] = floor_id
        # process the query parameters
        if user_id is not None:
            
            _query_params.append(('user_id', user_id))
            
        if app_id is not None:
            
            _query_params.append(('app_id', app_id))
            
        # process the header parameters
        # process the form parameters
        # process the body parameter


        # set the HTTP header `Accept`
        if 'Accept' not in _header_params:
            _header_params['Accept'] = self.api_client.select_header_accept(
                [
                    'application/json'
                ]
            )


        # authentication setting
        _auth_settings: List[str] = [
            'bearer'
        ]

        return self.api_client.param_serialize(
            method='POST',
            resource_path='/api/memory/make/floor/private/{floor_id}',
            path_params=_path_params,
            query_params=_query_params,
            header_params=_header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            auth_settings=_auth_settings,
            collection_formats=_collection_formats,
            _host=_host,
            _request_auth=_request_auth
        )




    @validate_call
    def make_floor_public(
        self,
        floor_id: StrictStr,
        user_id: Annotated[StrictStr, Field(description="User ID")],
        app_id: Annotated[StrictStr, Field(description="App ID")],
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> GetFloorInformation200Response:
        """Make floor public

        This API changes a floor’s visibility to **PUBLIC**. It is used when a floor owner wants to **make a private floor accessible to everyone**. After the update, the floor becomes public and can be viewed and discovered by any user, subject to platform rules (search, feeds, pods, etc.). This endpoint performs a **visibility state transition**:
        * **PRIVATE → PUBLIC**
        * If the floor is already public, the operation is treated as **idempotent** (no state change). This API is typically used from:
        * Floor settings → Privacy / Visibility controls
        * Owner or admin tools * Developer or pod-based applications using `app_id`
        
        ---
        
        **Request Method**
        
         `POST`
        
        ---
        
        **Content-Type**
        
         `application/x-www-form-urlencoded` (or `multipart/form-data`, depending on your implementation)
        
        ---
        
        **Request Parameters (Form Fields)**
        
        | Field | Type | Required | Description |
        | ---------- | ------ | -------- | ------------------------------------------------------------------------------- |
        | `user_id` | String | **Yes** | User requesting the change. Must be the **owner** of the floor. |
        | `floor_id` | String | **Yes** | Public identifier of the floor whose visibility is to be changed. |
        | `app_id` | String | No | Identifier of the calling application (used mainly for pod/developer contexts). |
        
        ---
        
        ### Authorization Rules (Critical)
        * The caller must be authenticated as `user_id`
        * **Only the floor owner** is allowed to change the floor’s visibility * Requests from non-owners must be rejected
        
        ---
        
        ### Behavior Rules
        * Converts floor visibility from **PRIVATE → PUBLIC**
        * Does not modify floor content, blocks, or ownership * Visibility change takes effect immediately
        
        ### Idempotency
        * If the floor is already public, the API should:
        * Return success with a message indicating no change, or
        * Return a specific “already public” status (implementation-dependent)
        
        ---
        
        ### Response Format `application/json`
        
        ---
        
        ### Sample
        
        Success Response
        
        ```json { \"status\":
        
        \"SUCCESS\", \"floor_id\": \"my_floor\", \"visibility\": \"PUBLIC\", \"message\": \"Floor is now public\" }
        
        ```
        
        ---
        
        ### Sample No-Op Response (Already Public)
        
        ```json { \"status\": \"SUCCESS\", \"floor_id\": \"my_floor\", \"visibility\": \"PUBLIC\", \"message\": \"Floor is already public\" }
        
        ```
        
        ---
        
        ### Error Responses (Examples)
        
        ### Not Authorized (Not Owner)
        
        ```json { \"status\": \"ERROR\", \"message\": \"Only the floor owner can change floor visibility\" }
        
        ```
        
        ---
        
        ### Floor Not Found
        
        ```json { \"status\":
        
        \"ERROR\", \"message\": \"Floor not found\" }
        
        ```
        
        ---
        
        ### Invalid Request
        
        ```json { \"status\":
        
        \"ERROR\", \"message\": \"user_id and floor_id are required\" }
        
        ```
        
        ---
        
        ### Notes for Developers
        * This API controls **visibility only**. Membership, invitations, and moderation rules are handled by separate APIs.
        * `app_id` is optional and primarily used for developer-managed or pod floors. * Clients should refresh floor metadata (e.g., via `/api/floor/info`)
        
        after a successful visibility change.
        
        ---
        
        ### Mental Model (One Line)
        
        > **This API answers: “Make this floor visible to everyone.”**

        :param floor_id:  (required)
        :type floor_id: str
        :param user_id: User ID (required)
        :type user_id: str
        :param app_id: App ID (required)
        :type app_id: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._make_floor_public_serialize(
            floor_id=floor_id,
            user_id=user_id,
            app_id=app_id,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "GetFloorInformation200Response",
            '400': "EditFloor400Response",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        ).data


    @validate_call
    def make_floor_public_with_http_info(
        self,
        floor_id: StrictStr,
        user_id: Annotated[StrictStr, Field(description="User ID")],
        app_id: Annotated[StrictStr, Field(description="App ID")],
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> ApiResponse[GetFloorInformation200Response]:
        """Make floor public

        This API changes a floor’s visibility to **PUBLIC**. It is used when a floor owner wants to **make a private floor accessible to everyone**. After the update, the floor becomes public and can be viewed and discovered by any user, subject to platform rules (search, feeds, pods, etc.). This endpoint performs a **visibility state transition**:
        * **PRIVATE → PUBLIC**
        * If the floor is already public, the operation is treated as **idempotent** (no state change). This API is typically used from:
        * Floor settings → Privacy / Visibility controls
        * Owner or admin tools * Developer or pod-based applications using `app_id`
        
        ---
        
        **Request Method**
        
         `POST`
        
        ---
        
        **Content-Type**
        
         `application/x-www-form-urlencoded` (or `multipart/form-data`, depending on your implementation)
        
        ---
        
        **Request Parameters (Form Fields)**
        
        | Field | Type | Required | Description |
        | ---------- | ------ | -------- | ------------------------------------------------------------------------------- |
        | `user_id` | String | **Yes** | User requesting the change. Must be the **owner** of the floor. |
        | `floor_id` | String | **Yes** | Public identifier of the floor whose visibility is to be changed. |
        | `app_id` | String | No | Identifier of the calling application (used mainly for pod/developer contexts). |
        
        ---
        
        ### Authorization Rules (Critical)
        * The caller must be authenticated as `user_id`
        * **Only the floor owner** is allowed to change the floor’s visibility * Requests from non-owners must be rejected
        
        ---
        
        ### Behavior Rules
        * Converts floor visibility from **PRIVATE → PUBLIC**
        * Does not modify floor content, blocks, or ownership * Visibility change takes effect immediately
        
        ### Idempotency
        * If the floor is already public, the API should:
        * Return success with a message indicating no change, or
        * Return a specific “already public” status (implementation-dependent)
        
        ---
        
        ### Response Format `application/json`
        
        ---
        
        ### Sample
        
        Success Response
        
        ```json { \"status\":
        
        \"SUCCESS\", \"floor_id\": \"my_floor\", \"visibility\": \"PUBLIC\", \"message\": \"Floor is now public\" }
        
        ```
        
        ---
        
        ### Sample No-Op Response (Already Public)
        
        ```json { \"status\": \"SUCCESS\", \"floor_id\": \"my_floor\", \"visibility\": \"PUBLIC\", \"message\": \"Floor is already public\" }
        
        ```
        
        ---
        
        ### Error Responses (Examples)
        
        ### Not Authorized (Not Owner)
        
        ```json { \"status\": \"ERROR\", \"message\": \"Only the floor owner can change floor visibility\" }
        
        ```
        
        ---
        
        ### Floor Not Found
        
        ```json { \"status\":
        
        \"ERROR\", \"message\": \"Floor not found\" }
        
        ```
        
        ---
        
        ### Invalid Request
        
        ```json { \"status\":
        
        \"ERROR\", \"message\": \"user_id and floor_id are required\" }
        
        ```
        
        ---
        
        ### Notes for Developers
        * This API controls **visibility only**. Membership, invitations, and moderation rules are handled by separate APIs.
        * `app_id` is optional and primarily used for developer-managed or pod floors. * Clients should refresh floor metadata (e.g., via `/api/floor/info`)
        
        after a successful visibility change.
        
        ---
        
        ### Mental Model (One Line)
        
        > **This API answers: “Make this floor visible to everyone.”**

        :param floor_id:  (required)
        :type floor_id: str
        :param user_id: User ID (required)
        :type user_id: str
        :param app_id: App ID (required)
        :type app_id: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._make_floor_public_serialize(
            floor_id=floor_id,
            user_id=user_id,
            app_id=app_id,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "GetFloorInformation200Response",
            '400': "EditFloor400Response",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        )


    @validate_call
    def make_floor_public_without_preload_content(
        self,
        floor_id: StrictStr,
        user_id: Annotated[StrictStr, Field(description="User ID")],
        app_id: Annotated[StrictStr, Field(description="App ID")],
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> RESTResponseType:
        """Make floor public

        This API changes a floor’s visibility to **PUBLIC**. It is used when a floor owner wants to **make a private floor accessible to everyone**. After the update, the floor becomes public and can be viewed and discovered by any user, subject to platform rules (search, feeds, pods, etc.). This endpoint performs a **visibility state transition**:
        * **PRIVATE → PUBLIC**
        * If the floor is already public, the operation is treated as **idempotent** (no state change). This API is typically used from:
        * Floor settings → Privacy / Visibility controls
        * Owner or admin tools * Developer or pod-based applications using `app_id`
        
        ---
        
        **Request Method**
        
         `POST`
        
        ---
        
        **Content-Type**
        
         `application/x-www-form-urlencoded` (or `multipart/form-data`, depending on your implementation)
        
        ---
        
        **Request Parameters (Form Fields)**
        
        | Field | Type | Required | Description |
        | ---------- | ------ | -------- | ------------------------------------------------------------------------------- |
        | `user_id` | String | **Yes** | User requesting the change. Must be the **owner** of the floor. |
        | `floor_id` | String | **Yes** | Public identifier of the floor whose visibility is to be changed. |
        | `app_id` | String | No | Identifier of the calling application (used mainly for pod/developer contexts). |
        
        ---
        
        ### Authorization Rules (Critical)
        * The caller must be authenticated as `user_id`
        * **Only the floor owner** is allowed to change the floor’s visibility * Requests from non-owners must be rejected
        
        ---
        
        ### Behavior Rules
        * Converts floor visibility from **PRIVATE → PUBLIC**
        * Does not modify floor content, blocks, or ownership * Visibility change takes effect immediately
        
        ### Idempotency
        * If the floor is already public, the API should:
        * Return success with a message indicating no change, or
        * Return a specific “already public” status (implementation-dependent)
        
        ---
        
        ### Response Format `application/json`
        
        ---
        
        ### Sample
        
        Success Response
        
        ```json { \"status\":
        
        \"SUCCESS\", \"floor_id\": \"my_floor\", \"visibility\": \"PUBLIC\", \"message\": \"Floor is now public\" }
        
        ```
        
        ---
        
        ### Sample No-Op Response (Already Public)
        
        ```json { \"status\": \"SUCCESS\", \"floor_id\": \"my_floor\", \"visibility\": \"PUBLIC\", \"message\": \"Floor is already public\" }
        
        ```
        
        ---
        
        ### Error Responses (Examples)
        
        ### Not Authorized (Not Owner)
        
        ```json { \"status\": \"ERROR\", \"message\": \"Only the floor owner can change floor visibility\" }
        
        ```
        
        ---
        
        ### Floor Not Found
        
        ```json { \"status\":
        
        \"ERROR\", \"message\": \"Floor not found\" }
        
        ```
        
        ---
        
        ### Invalid Request
        
        ```json { \"status\":
        
        \"ERROR\", \"message\": \"user_id and floor_id are required\" }
        
        ```
        
        ---
        
        ### Notes for Developers
        * This API controls **visibility only**. Membership, invitations, and moderation rules are handled by separate APIs.
        * `app_id` is optional and primarily used for developer-managed or pod floors. * Clients should refresh floor metadata (e.g., via `/api/floor/info`)
        
        after a successful visibility change.
        
        ---
        
        ### Mental Model (One Line)
        
        > **This API answers: “Make this floor visible to everyone.”**

        :param floor_id:  (required)
        :type floor_id: str
        :param user_id: User ID (required)
        :type user_id: str
        :param app_id: App ID (required)
        :type app_id: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._make_floor_public_serialize(
            floor_id=floor_id,
            user_id=user_id,
            app_id=app_id,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "GetFloorInformation200Response",
            '400': "EditFloor400Response",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        return response_data.response


    def _make_floor_public_serialize(
        self,
        floor_id,
        user_id,
        app_id,
        _request_auth,
        _content_type,
        _headers,
        _host_index,
    ) -> RequestSerialized:

        _host = None

        _collection_formats: Dict[str, str] = {
        }

        _path_params: Dict[str, str] = {}
        _query_params: List[Tuple[str, str]] = []
        _header_params: Dict[str, Optional[str]] = _headers or {}
        _form_params: List[Tuple[str, str]] = []
        _files: Dict[
            str, Union[str, bytes, List[str], List[bytes], List[Tuple[str, bytes]]]
        ] = {}
        _body_params: Optional[bytes] = None

        # process the path parameters
        if floor_id is not None:
            _path_params['floor_id'] = floor_id
        # process the query parameters
        if user_id is not None:
            
            _query_params.append(('user_id', user_id))
            
        if app_id is not None:
            
            _query_params.append(('app_id', app_id))
            
        # process the header parameters
        # process the form parameters
        # process the body parameter


        # set the HTTP header `Accept`
        if 'Accept' not in _header_params:
            _header_params['Accept'] = self.api_client.select_header_accept(
                [
                    'application/json'
                ]
            )


        # authentication setting
        _auth_settings: List[str] = [
            'bearer'
        ]

        return self.api_client.param_serialize(
            method='POST',
            resource_path='/api/memory/make/floor/public/{floor_id}',
            path_params=_path_params,
            query_params=_query_params,
            header_params=_header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            auth_settings=_auth_settings,
            collection_formats=_collection_formats,
            _host=_host,
            _request_auth=_request_auth
        )




    @validate_call
    def register_external_user_identity(
        self,
        mobile_number: Optional[StrictStr] = None,
        email_id: Optional[StrictStr] = None,
        name: Optional[StrictStr] = None,
        app_id: Optional[StrictStr] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> SignInWithEmail200Response:
        """External User Registration

        This API allows a calling application to **pass externally authenticated user identity information to xfloor** after completing authentication within its own system. xfloor **does not perform authentication, credential verification, or session management** as part of this API. The calling application is fully responsible for validating the user and ensuring the correctness of the identity data provided. Upon invocation, xfloor will:
        * **Create a new user profile** if no matching user exists, or
        * **Update the existing user profile** if the user is already present. xfloor returns a unique `xfloor_user_id`, which serves as the **canonical user identifier** and must be used in all subsequent xfloor APIs, including floors, blocks, conversations, memory interactions, and analytics.

        :param mobile_number:
        :type mobile_number: str
        :param email_id:
        :type email_id: str
        :param name:
        :type name: str
        :param app_id:
        :type app_id: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._register_external_user_identity_serialize(
            mobile_number=mobile_number,
            email_id=email_id,
            name=name,
            app_id=app_id,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "SignInWithEmail200Response",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        ).data


    @validate_call
    def register_external_user_identity_with_http_info(
        self,
        mobile_number: Optional[StrictStr] = None,
        email_id: Optional[StrictStr] = None,
        name: Optional[StrictStr] = None,
        app_id: Optional[StrictStr] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> ApiResponse[SignInWithEmail200Response]:
        """External User Registration

        This API allows a calling application to **pass externally authenticated user identity information to xfloor** after completing authentication within its own system. xfloor **does not perform authentication, credential verification, or session management** as part of this API. The calling application is fully responsible for validating the user and ensuring the correctness of the identity data provided. Upon invocation, xfloor will:
        * **Create a new user profile** if no matching user exists, or
        * **Update the existing user profile** if the user is already present. xfloor returns a unique `xfloor_user_id`, which serves as the **canonical user identifier** and must be used in all subsequent xfloor APIs, including floors, blocks, conversations, memory interactions, and analytics.

        :param mobile_number:
        :type mobile_number: str
        :param email_id:
        :type email_id: str
        :param name:
        :type name: str
        :param app_id:
        :type app_id: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._register_external_user_identity_serialize(
            mobile_number=mobile_number,
            email_id=email_id,
            name=name,
            app_id=app_id,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "SignInWithEmail200Response",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        )


    @validate_call
    def register_external_user_identity_without_preload_content(
        self,
        mobile_number: Optional[StrictStr] = None,
        email_id: Optional[StrictStr] = None,
        name: Optional[StrictStr] = None,
        app_id: Optional[StrictStr] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> RESTResponseType:
        """External User Registration

        This API allows a calling application to **pass externally authenticated user identity information to xfloor** after completing authentication within its own system. xfloor **does not perform authentication, credential verification, or session management** as part of this API. The calling application is fully responsible for validating the user and ensuring the correctness of the identity data provided. Upon invocation, xfloor will:
        * **Create a new user profile** if no matching user exists, or
        * **Update the existing user profile** if the user is already present. xfloor returns a unique `xfloor_user_id`, which serves as the **canonical user identifier** and must be used in all subsequent xfloor APIs, including floors, blocks, conversations, memory interactions, and analytics.

        :param mobile_number:
        :type mobile_number: str
        :param email_id:
        :type email_id: str
        :param name:
        :type name: str
        :param app_id:
        :type app_id: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._register_external_user_identity_serialize(
            mobile_number=mobile_number,
            email_id=email_id,
            name=name,
            app_id=app_id,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "SignInWithEmail200Response",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        return response_data.response


    def _register_external_user_identity_serialize(
        self,
        mobile_number,
        email_id,
        name,
        app_id,
        _request_auth,
        _content_type,
        _headers,
        _host_index,
    ) -> RequestSerialized:

        _host = None

        _collection_formats: Dict[str, str] = {
        }

        _path_params: Dict[str, str] = {}
        _query_params: List[Tuple[str, str]] = []
        _header_params: Dict[str, Optional[str]] = _headers or {}
        _form_params: List[Tuple[str, str]] = []
        _files: Dict[
            str, Union[str, bytes, List[str], List[bytes], List[Tuple[str, bytes]]]
        ] = {}
        _body_params: Optional[bytes] = None

        # process the path parameters
        # process the query parameters
        # process the header parameters
        # process the form parameters
        if mobile_number is not None:
            _form_params.append(('mobile_number', mobile_number))
        if email_id is not None:
            _form_params.append(('email_id', email_id))
        if name is not None:
            _form_params.append(('name', name))
        if app_id is not None:
            _form_params.append(('app_id', app_id))
        # process the body parameter


        # set the HTTP header `Accept`
        if 'Accept' not in _header_params:
            _header_params['Accept'] = self.api_client.select_header_accept(
                [
                    'application/json'
                ]
            )

        # set the HTTP header `Content-Type`
        if _content_type:
            _header_params['Content-Type'] = _content_type
        else:
            _default_content_type = (
                self.api_client.select_header_content_type(
                    [
                        'multipart/form-data'
                    ]
                )
            )
            if _default_content_type is not None:
                _header_params['Content-Type'] = _default_content_type

        # authentication setting
        _auth_settings: List[str] = [
            'bearer'
        ]

        return self.api_client.param_serialize(
            method='POST',
            resource_path='/memory/identity/external-user',
            path_params=_path_params,
            query_params=_query_params,
            header_params=_header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            auth_settings=_auth_settings,
            collection_formats=_collection_formats,
            _host=_host,
            _request_auth=_request_auth
        )




    @validate_call
    def rename_floor(
        self,
        user_id: Annotated[StrictStr, Field(description="User ID")],
        app_id: Annotated[StrictStr, Field(description="App ID")],
        var_from: Annotated[StrictStr, Field(description="Old floor ID")],
        to: Annotated[StrictStr, Field(description="New floor ID")],
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> GetFloorInformation200Response:
        """Rename floor

        This API renames a floor by changing knowing the **floor identifier (floor_id)**. It allows the **floor owner** to update the public-facing floor ID (slug/handle) from an old value to a new value. This is typically used when the owner wants to rebrand, reorganize, or correct the floor’s identifier. ⚠️ **This operation affects how the floor is accessed and referenced externally**, so it must be performed carefully.
        
        ---
        
        ### Ownership & Authorization (Critical)
        * The caller **must be authenticated**
        * **Only the floor owner** is allowed to rename a floor * Members, followers, or non-owners **cannot** perform this operation * Ownership is validated internally using `user_id` > If the user is not the owner, the request must be rejected.
        
        ---
        
        **Request Method**
        
         `POST`
        
        ---
        
        **Content-Type**
        
         `application/x-www-form-urlencoded` (or equivalent form-data encoding)
        
        ---
        
        **Request Parameters (Form Fields)**
        
        | Parameter | Type | Required | Description |
        | --------- | ------ | -------- | ------------------------------------------------------------------------------- |
        | `user_id` | String | **Yes** | User requesting the rename. Must be the **owner** of the floor. |
        | `from` | String | **Yes** | Existing floor ID (current identifier to be renamed). |
        | `to` | String | **Yes** | New floor ID to assign to the floor. |
        | `app_id` | String | No | Identifier of the calling application (used mainly for pod/developer contexts). |
        
        ---
        
        ### Rename Rules & Constraints
        * The `from` floor ID **must exist**
        * The `to` floor ID **must be unique** and not already in use * The rename operation updates **only the floor ID**
        * Floor ownership, blocks, posts, and internal `fid` remain unchanged
        * Any links or references using the old floor ID may no longer be valid after rename
        
        ---
        
        ### Behavior Summary
        
        | Scenario | Result |
        | ---------------------------- | ------------------------------------------------- |
        | Valid owner + unique new ID | Floor ID renamed successfully |
        | Non-owner user | Request rejected |
        | `from` floor ID not found | Error |
        | `to` floor ID already exists | Error |
        | `from` == `to` | No-op or validation error (implementation choice) |
        
        ---
        
        ### Response Format `application/json`
        
        ---
        
        ### Sample
        
        Success Response
        
        ```json { \"status\":
        
        \"SUCCESS\", \"old_floor_id\": \"oldfloorid\", \"new_floor_id\": \"newfloorid\", \"message\": \"Floor ID renamed successfully\" }
        
        ```
        
        ---
        
        ### Sample
        
        Error Responses
        
        ### Not Floor Owner
        
        ```json { \"status\":
        
        \"ERROR\", \"message\": \"Only the floor owner can rename the floor\" }
        
        ```
        
        ---
        
        ### Floor Not Found
        
        ```json { \"status\":
        
        \"ERROR\", \"message\": \"Source floor ID does not exist\" }
        
        ```
        
        ---
        
        ### Floor ID Already Exists
        
        ```json { \"status\":
        
        \"ERROR\", \"message\": \"Target floor ID is already in use\" }
        
        ```
        
        ---
        
        ### Invalid Request
        
        ```json { \"status\":
        
        \"ERROR\", \"message\": \"user_id, from, and to are required\" }
        
        ```
        
        ---
        
        ### Notes for Developers
        * This API **renames the public identifier only**; the internal immutable floor ID (`fid`)
        
        is not affected. * Clients should refresh cached floor metadata after a successful rename. * If your platform supports deep links or bookmarks, consider redirect or alias handling for old floor IDs (if supported).
        
        ---
        
        ### One-Line Mental Model 
        
        > **This API answers:
        
        “Change the public identity (ID)
        
        of a floor, owner-only.”**

        :param user_id: User ID (required)
        :type user_id: str
        :param app_id: App ID (required)
        :type app_id: str
        :param var_from: Old floor ID (required)
        :type var_from: str
        :param to: New floor ID (required)
        :type to: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._rename_floor_serialize(
            user_id=user_id,
            app_id=app_id,
            var_from=var_from,
            to=to,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "GetFloorInformation200Response",
            '400': "GetRecentEvents400Response",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        ).data


    @validate_call
    def rename_floor_with_http_info(
        self,
        user_id: Annotated[StrictStr, Field(description="User ID")],
        app_id: Annotated[StrictStr, Field(description="App ID")],
        var_from: Annotated[StrictStr, Field(description="Old floor ID")],
        to: Annotated[StrictStr, Field(description="New floor ID")],
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> ApiResponse[GetFloorInformation200Response]:
        """Rename floor

        This API renames a floor by changing knowing the **floor identifier (floor_id)**. It allows the **floor owner** to update the public-facing floor ID (slug/handle) from an old value to a new value. This is typically used when the owner wants to rebrand, reorganize, or correct the floor’s identifier. ⚠️ **This operation affects how the floor is accessed and referenced externally**, so it must be performed carefully.
        
        ---
        
        ### Ownership & Authorization (Critical)
        * The caller **must be authenticated**
        * **Only the floor owner** is allowed to rename a floor * Members, followers, or non-owners **cannot** perform this operation * Ownership is validated internally using `user_id` > If the user is not the owner, the request must be rejected.
        
        ---
        
        **Request Method**
        
         `POST`
        
        ---
        
        **Content-Type**
        
         `application/x-www-form-urlencoded` (or equivalent form-data encoding)
        
        ---
        
        **Request Parameters (Form Fields)**
        
        | Parameter | Type | Required | Description |
        | --------- | ------ | -------- | ------------------------------------------------------------------------------- |
        | `user_id` | String | **Yes** | User requesting the rename. Must be the **owner** of the floor. |
        | `from` | String | **Yes** | Existing floor ID (current identifier to be renamed). |
        | `to` | String | **Yes** | New floor ID to assign to the floor. |
        | `app_id` | String | No | Identifier of the calling application (used mainly for pod/developer contexts). |
        
        ---
        
        ### Rename Rules & Constraints
        * The `from` floor ID **must exist**
        * The `to` floor ID **must be unique** and not already in use * The rename operation updates **only the floor ID**
        * Floor ownership, blocks, posts, and internal `fid` remain unchanged
        * Any links or references using the old floor ID may no longer be valid after rename
        
        ---
        
        ### Behavior Summary
        
        | Scenario | Result |
        | ---------------------------- | ------------------------------------------------- |
        | Valid owner + unique new ID | Floor ID renamed successfully |
        | Non-owner user | Request rejected |
        | `from` floor ID not found | Error |
        | `to` floor ID already exists | Error |
        | `from` == `to` | No-op or validation error (implementation choice) |
        
        ---
        
        ### Response Format `application/json`
        
        ---
        
        ### Sample
        
        Success Response
        
        ```json { \"status\":
        
        \"SUCCESS\", \"old_floor_id\": \"oldfloorid\", \"new_floor_id\": \"newfloorid\", \"message\": \"Floor ID renamed successfully\" }
        
        ```
        
        ---
        
        ### Sample
        
        Error Responses
        
        ### Not Floor Owner
        
        ```json { \"status\":
        
        \"ERROR\", \"message\": \"Only the floor owner can rename the floor\" }
        
        ```
        
        ---
        
        ### Floor Not Found
        
        ```json { \"status\":
        
        \"ERROR\", \"message\": \"Source floor ID does not exist\" }
        
        ```
        
        ---
        
        ### Floor ID Already Exists
        
        ```json { \"status\":
        
        \"ERROR\", \"message\": \"Target floor ID is already in use\" }
        
        ```
        
        ---
        
        ### Invalid Request
        
        ```json { \"status\":
        
        \"ERROR\", \"message\": \"user_id, from, and to are required\" }
        
        ```
        
        ---
        
        ### Notes for Developers
        * This API **renames the public identifier only**; the internal immutable floor ID (`fid`)
        
        is not affected. * Clients should refresh cached floor metadata after a successful rename. * If your platform supports deep links or bookmarks, consider redirect or alias handling for old floor IDs (if supported).
        
        ---
        
        ### One-Line Mental Model 
        
        > **This API answers:
        
        “Change the public identity (ID)
        
        of a floor, owner-only.”**

        :param user_id: User ID (required)
        :type user_id: str
        :param app_id: App ID (required)
        :type app_id: str
        :param var_from: Old floor ID (required)
        :type var_from: str
        :param to: New floor ID (required)
        :type to: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._rename_floor_serialize(
            user_id=user_id,
            app_id=app_id,
            var_from=var_from,
            to=to,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "GetFloorInformation200Response",
            '400': "GetRecentEvents400Response",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        )


    @validate_call
    def rename_floor_without_preload_content(
        self,
        user_id: Annotated[StrictStr, Field(description="User ID")],
        app_id: Annotated[StrictStr, Field(description="App ID")],
        var_from: Annotated[StrictStr, Field(description="Old floor ID")],
        to: Annotated[StrictStr, Field(description="New floor ID")],
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> RESTResponseType:
        """Rename floor

        This API renames a floor by changing knowing the **floor identifier (floor_id)**. It allows the **floor owner** to update the public-facing floor ID (slug/handle) from an old value to a new value. This is typically used when the owner wants to rebrand, reorganize, or correct the floor’s identifier. ⚠️ **This operation affects how the floor is accessed and referenced externally**, so it must be performed carefully.
        
        ---
        
        ### Ownership & Authorization (Critical)
        * The caller **must be authenticated**
        * **Only the floor owner** is allowed to rename a floor * Members, followers, or non-owners **cannot** perform this operation * Ownership is validated internally using `user_id` > If the user is not the owner, the request must be rejected.
        
        ---
        
        **Request Method**
        
         `POST`
        
        ---
        
        **Content-Type**
        
         `application/x-www-form-urlencoded` (or equivalent form-data encoding)
        
        ---
        
        **Request Parameters (Form Fields)**
        
        | Parameter | Type | Required | Description |
        | --------- | ------ | -------- | ------------------------------------------------------------------------------- |
        | `user_id` | String | **Yes** | User requesting the rename. Must be the **owner** of the floor. |
        | `from` | String | **Yes** | Existing floor ID (current identifier to be renamed). |
        | `to` | String | **Yes** | New floor ID to assign to the floor. |
        | `app_id` | String | No | Identifier of the calling application (used mainly for pod/developer contexts). |
        
        ---
        
        ### Rename Rules & Constraints
        * The `from` floor ID **must exist**
        * The `to` floor ID **must be unique** and not already in use * The rename operation updates **only the floor ID**
        * Floor ownership, blocks, posts, and internal `fid` remain unchanged
        * Any links or references using the old floor ID may no longer be valid after rename
        
        ---
        
        ### Behavior Summary
        
        | Scenario | Result |
        | ---------------------------- | ------------------------------------------------- |
        | Valid owner + unique new ID | Floor ID renamed successfully |
        | Non-owner user | Request rejected |
        | `from` floor ID not found | Error |
        | `to` floor ID already exists | Error |
        | `from` == `to` | No-op or validation error (implementation choice) |
        
        ---
        
        ### Response Format `application/json`
        
        ---
        
        ### Sample
        
        Success Response
        
        ```json { \"status\":
        
        \"SUCCESS\", \"old_floor_id\": \"oldfloorid\", \"new_floor_id\": \"newfloorid\", \"message\": \"Floor ID renamed successfully\" }
        
        ```
        
        ---
        
        ### Sample
        
        Error Responses
        
        ### Not Floor Owner
        
        ```json { \"status\":
        
        \"ERROR\", \"message\": \"Only the floor owner can rename the floor\" }
        
        ```
        
        ---
        
        ### Floor Not Found
        
        ```json { \"status\":
        
        \"ERROR\", \"message\": \"Source floor ID does not exist\" }
        
        ```
        
        ---
        
        ### Floor ID Already Exists
        
        ```json { \"status\":
        
        \"ERROR\", \"message\": \"Target floor ID is already in use\" }
        
        ```
        
        ---
        
        ### Invalid Request
        
        ```json { \"status\":
        
        \"ERROR\", \"message\": \"user_id, from, and to are required\" }
        
        ```
        
        ---
        
        ### Notes for Developers
        * This API **renames the public identifier only**; the internal immutable floor ID (`fid`)
        
        is not affected. * Clients should refresh cached floor metadata after a successful rename. * If your platform supports deep links or bookmarks, consider redirect or alias handling for old floor IDs (if supported).
        
        ---
        
        ### One-Line Mental Model 
        
        > **This API answers:
        
        “Change the public identity (ID)
        
        of a floor, owner-only.”**

        :param user_id: User ID (required)
        :type user_id: str
        :param app_id: App ID (required)
        :type app_id: str
        :param var_from: Old floor ID (required)
        :type var_from: str
        :param to: New floor ID (required)
        :type to: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._rename_floor_serialize(
            user_id=user_id,
            app_id=app_id,
            var_from=var_from,
            to=to,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "GetFloorInformation200Response",
            '400': "GetRecentEvents400Response",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        return response_data.response


    def _rename_floor_serialize(
        self,
        user_id,
        app_id,
        var_from,
        to,
        _request_auth,
        _content_type,
        _headers,
        _host_index,
    ) -> RequestSerialized:

        _host = None

        _collection_formats: Dict[str, str] = {
        }

        _path_params: Dict[str, str] = {}
        _query_params: List[Tuple[str, str]] = []
        _header_params: Dict[str, Optional[str]] = _headers or {}
        _form_params: List[Tuple[str, str]] = []
        _files: Dict[
            str, Union[str, bytes, List[str], List[bytes], List[Tuple[str, bytes]]]
        ] = {}
        _body_params: Optional[bytes] = None

        # process the path parameters
        # process the query parameters
        if user_id is not None:
            
            _query_params.append(('user_id', user_id))
            
        if app_id is not None:
            
            _query_params.append(('app_id', app_id))
            
        if var_from is not None:
            
            _query_params.append(('from', var_from))
            
        if to is not None:
            
            _query_params.append(('to', to))
            
        # process the header parameters
        # process the form parameters
        # process the body parameter


        # set the HTTP header `Accept`
        if 'Accept' not in _header_params:
            _header_params['Accept'] = self.api_client.select_header_accept(
                [
                    'application/json'
                ]
            )


        # authentication setting
        _auth_settings: List[str] = [
            'bearer'
        ]

        return self.api_client.param_serialize(
            method='POST',
            resource_path='/api/memory/change/floor/id',
            path_params=_path_params,
            query_params=_query_params,
            header_params=_header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            auth_settings=_auth_settings,
            collection_formats=_collection_formats,
            _host=_host,
            _request_auth=_request_auth
        )




    @validate_call
    def reset_password(
        self,
        activation_code: Annotated[StrictStr, Field(description="Activation Code")],
        email_id: Annotated[Optional[StrictStr], Field(description="Email ID")] = None,
        mobile_number: Annotated[Optional[StrictStr], Field(description="Mobile number")] = None,
        app_id: Annotated[Optional[StrictStr], Field(description="App ID")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> ResetPassword200Response:
        """Reset Password

        ---
        
        ### Reset Password (Forgot Password, Not Logged In) Resets the password of a user who **cannot log in** and is using a **forgot-password** flow. This endpoint is used when the user is not authenticated and requests a password reset using a verified identity channel such as **email** or **mobile number**. The system validates a **one-time reset verification code** (`activation_code`) issued for the reset-password flow. If valid and not expired, the password is updated to `new_password` and takes effect immediately. If verification fails, the password remains unchanged and an error response is returned.
        
        ### Authentication ✅ **Recommended** (better security): a short-lived **reset token** issued after initiating reset
        
        ``` Authorization: Bearer <reset_token>
        
        ``` > If you don’t use a reset token, you must enforce strong rate limiting + OTP attempt throttling on this endpoint.
        
        **Request Body**
        
        (Form Data)
        * `email_id` or `mobile_number` (required to identify user)
        * `activation_code` (required) * `new_password` (required) * `user_id` (optional, if your reset flow already resolved it)
        
        ### Behavior Notes
        * Requires a prior call to **initiate reset** and send OTP/code (mode = forgot password).
        * Must enforce code attempt limits and expiration strictly.
        
        ### One-Line Summary > Resets a user’s password (forgot-password flow) after validating a one-time reset code sent to email or mobile.

        :param activation_code: Activation Code (required)
        :type activation_code: str
        :param email_id: Email ID
        :type email_id: str
        :param mobile_number: Mobile number
        :type mobile_number: str
        :param app_id: App ID
        :type app_id: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._reset_password_serialize(
            activation_code=activation_code,
            email_id=email_id,
            mobile_number=mobile_number,
            app_id=app_id,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "ResetPassword200Response",
            '400': "ResetPassword400Response",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        ).data


    @validate_call
    def reset_password_with_http_info(
        self,
        activation_code: Annotated[StrictStr, Field(description="Activation Code")],
        email_id: Annotated[Optional[StrictStr], Field(description="Email ID")] = None,
        mobile_number: Annotated[Optional[StrictStr], Field(description="Mobile number")] = None,
        app_id: Annotated[Optional[StrictStr], Field(description="App ID")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> ApiResponse[ResetPassword200Response]:
        """Reset Password

        ---
        
        ### Reset Password (Forgot Password, Not Logged In) Resets the password of a user who **cannot log in** and is using a **forgot-password** flow. This endpoint is used when the user is not authenticated and requests a password reset using a verified identity channel such as **email** or **mobile number**. The system validates a **one-time reset verification code** (`activation_code`) issued for the reset-password flow. If valid and not expired, the password is updated to `new_password` and takes effect immediately. If verification fails, the password remains unchanged and an error response is returned.
        
        ### Authentication ✅ **Recommended** (better security): a short-lived **reset token** issued after initiating reset
        
        ``` Authorization: Bearer <reset_token>
        
        ``` > If you don’t use a reset token, you must enforce strong rate limiting + OTP attempt throttling on this endpoint.
        
        **Request Body**
        
        (Form Data)
        * `email_id` or `mobile_number` (required to identify user)
        * `activation_code` (required) * `new_password` (required) * `user_id` (optional, if your reset flow already resolved it)
        
        ### Behavior Notes
        * Requires a prior call to **initiate reset** and send OTP/code (mode = forgot password).
        * Must enforce code attempt limits and expiration strictly.
        
        ### One-Line Summary > Resets a user’s password (forgot-password flow) after validating a one-time reset code sent to email or mobile.

        :param activation_code: Activation Code (required)
        :type activation_code: str
        :param email_id: Email ID
        :type email_id: str
        :param mobile_number: Mobile number
        :type mobile_number: str
        :param app_id: App ID
        :type app_id: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._reset_password_serialize(
            activation_code=activation_code,
            email_id=email_id,
            mobile_number=mobile_number,
            app_id=app_id,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "ResetPassword200Response",
            '400': "ResetPassword400Response",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        )


    @validate_call
    def reset_password_without_preload_content(
        self,
        activation_code: Annotated[StrictStr, Field(description="Activation Code")],
        email_id: Annotated[Optional[StrictStr], Field(description="Email ID")] = None,
        mobile_number: Annotated[Optional[StrictStr], Field(description="Mobile number")] = None,
        app_id: Annotated[Optional[StrictStr], Field(description="App ID")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> RESTResponseType:
        """Reset Password

        ---
        
        ### Reset Password (Forgot Password, Not Logged In) Resets the password of a user who **cannot log in** and is using a **forgot-password** flow. This endpoint is used when the user is not authenticated and requests a password reset using a verified identity channel such as **email** or **mobile number**. The system validates a **one-time reset verification code** (`activation_code`) issued for the reset-password flow. If valid and not expired, the password is updated to `new_password` and takes effect immediately. If verification fails, the password remains unchanged and an error response is returned.
        
        ### Authentication ✅ **Recommended** (better security): a short-lived **reset token** issued after initiating reset
        
        ``` Authorization: Bearer <reset_token>
        
        ``` > If you don’t use a reset token, you must enforce strong rate limiting + OTP attempt throttling on this endpoint.
        
        **Request Body**
        
        (Form Data)
        * `email_id` or `mobile_number` (required to identify user)
        * `activation_code` (required) * `new_password` (required) * `user_id` (optional, if your reset flow already resolved it)
        
        ### Behavior Notes
        * Requires a prior call to **initiate reset** and send OTP/code (mode = forgot password).
        * Must enforce code attempt limits and expiration strictly.
        
        ### One-Line Summary > Resets a user’s password (forgot-password flow) after validating a one-time reset code sent to email or mobile.

        :param activation_code: Activation Code (required)
        :type activation_code: str
        :param email_id: Email ID
        :type email_id: str
        :param mobile_number: Mobile number
        :type mobile_number: str
        :param app_id: App ID
        :type app_id: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._reset_password_serialize(
            activation_code=activation_code,
            email_id=email_id,
            mobile_number=mobile_number,
            app_id=app_id,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "ResetPassword200Response",
            '400': "ResetPassword400Response",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        return response_data.response


    def _reset_password_serialize(
        self,
        activation_code,
        email_id,
        mobile_number,
        app_id,
        _request_auth,
        _content_type,
        _headers,
        _host_index,
    ) -> RequestSerialized:

        _host = None

        _collection_formats: Dict[str, str] = {
        }

        _path_params: Dict[str, str] = {}
        _query_params: List[Tuple[str, str]] = []
        _header_params: Dict[str, Optional[str]] = _headers or {}
        _form_params: List[Tuple[str, str]] = []
        _files: Dict[
            str, Union[str, bytes, List[str], List[bytes], List[Tuple[str, bytes]]]
        ] = {}
        _body_params: Optional[bytes] = None

        # process the path parameters
        # process the query parameters
        if email_id is not None:
            
            _query_params.append(('email_id', email_id))
            
        if mobile_number is not None:
            
            _query_params.append(('mobile_number', mobile_number))
            
        if activation_code is not None:
            
            _query_params.append(('activation_code', activation_code))
            
        if app_id is not None:
            
            _query_params.append(('app_id', app_id))
            
        # process the header parameters
        # process the form parameters
        # process the body parameter


        # set the HTTP header `Accept`
        if 'Accept' not in _header_params:
            _header_params['Accept'] = self.api_client.select_header_accept(
                [
                    'application/json'
                ]
            )


        # authentication setting
        _auth_settings: List[str] = [
        ]

        return self.api_client.param_serialize(
            method='POST',
            resource_path='/auth-service/password/reset',
            path_params=_path_params,
            query_params=_query_params,
            header_params=_header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            auth_settings=_auth_settings,
            collection_formats=_collection_formats,
            _host=_host,
            _request_auth=_request_auth
        )




    @validate_call
    def send_sign_in_validation_code(
        self,
        app_id: Annotated[StrictStr, Field(description="App ID")],
        mobile_number: Annotated[Optional[StrictStr], Field(description="Mobile number")] = None,
        email_id: Annotated[Optional[StrictStr], Field(description="Email ID")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> SendSignInValidationCode200Response:
        """Send Sign-In Validation Code (OTP)

        This API initiates the **sign-in validation process** by sending a **one-time validation code (OTP)** to the user. The OTP is delivered to **either the mobile number or the email address** provided in the request. This endpoint is typically called **before completing sign-in**, to verify that the user owns the supplied contact identifier. The calling application is responsible for:
        * Collecting the OTP from the user
        * Submitting it to the OTP verification API (handled separately)
        
        ---
        
        ### **Use Case**
        * User attempts to sign in
        * User provides **mobile number or email** * System sends a **validation code (OTP)**
        * User enters OTP to complete sign-in
        
        ---
        
        ### **Request Method**
        
         `POST`
        
        ---
        
        ### **Formdata Parameters**
        
        | Parameter Name | Type | Required | Description |
        | --------------- | ------ | --------- | ------------------------------------------- |
        | `mobile_number` | String | Optional* | Mobile number to which the OTP will be sent |
        | `email_id` | String | Optional* | Email address to which the OTP will be sent |
        | `app_id` | String | Optional | Identifier of the calling application |
        * **Either `mobile_number` or `email_id` must be provided.** Providing both is allowed; the system may choose one based on configuration.
        
        ---
        
        ### **Request Rules**
        * At least **one** of `mobile_number` or `email_id` is mandatory
        * If both are missing, the request will be rejected * OTP delivery channel depends on the provided identifier
        
        ---
        
        ### **Response Format**
        
         `application/json`
        
        ---
        
        ### **Sample
        
        Success Response**
        
        ```json { \"status\": \"SUCCESS\", \"message\": \"Validation code sent successfully\" }
        
        ```
        
        ---
        
        ### **Sample
        
        Error Responses**
        
        ### Missing Identifier
        
        ```json { \"status\": \"ERROR\", \"message\": \"Either mobile_number or email_id must be provided\" }
        
        ```
        
        ### Invalid Identifier
        
        ```json { \"status\": \"ERROR\", \"message\": \"Invalid mobile number or email address\" }
        
        ```
        
        ---
        
        ### **Notes**
        * This API **only sends** the validation code
        * OTP verification must be performed using the corresponding **verify validation code** API * Rate limiting and retry restrictions may apply to prevent abuse

        :param app_id: App ID (required)
        :type app_id: str
        :param mobile_number: Mobile number
        :type mobile_number: str
        :param email_id: Email ID
        :type email_id: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._send_sign_in_validation_code_serialize(
            app_id=app_id,
            mobile_number=mobile_number,
            email_id=email_id,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "SendSignInValidationCode200Response",
            '400': "ResetPassword400Response",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        ).data


    @validate_call
    def send_sign_in_validation_code_with_http_info(
        self,
        app_id: Annotated[StrictStr, Field(description="App ID")],
        mobile_number: Annotated[Optional[StrictStr], Field(description="Mobile number")] = None,
        email_id: Annotated[Optional[StrictStr], Field(description="Email ID")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> ApiResponse[SendSignInValidationCode200Response]:
        """Send Sign-In Validation Code (OTP)

        This API initiates the **sign-in validation process** by sending a **one-time validation code (OTP)** to the user. The OTP is delivered to **either the mobile number or the email address** provided in the request. This endpoint is typically called **before completing sign-in**, to verify that the user owns the supplied contact identifier. The calling application is responsible for:
        * Collecting the OTP from the user
        * Submitting it to the OTP verification API (handled separately)
        
        ---
        
        ### **Use Case**
        * User attempts to sign in
        * User provides **mobile number or email** * System sends a **validation code (OTP)**
        * User enters OTP to complete sign-in
        
        ---
        
        ### **Request Method**
        
         `POST`
        
        ---
        
        ### **Formdata Parameters**
        
        | Parameter Name | Type | Required | Description |
        | --------------- | ------ | --------- | ------------------------------------------- |
        | `mobile_number` | String | Optional* | Mobile number to which the OTP will be sent |
        | `email_id` | String | Optional* | Email address to which the OTP will be sent |
        | `app_id` | String | Optional | Identifier of the calling application |
        * **Either `mobile_number` or `email_id` must be provided.** Providing both is allowed; the system may choose one based on configuration.
        
        ---
        
        ### **Request Rules**
        * At least **one** of `mobile_number` or `email_id` is mandatory
        * If both are missing, the request will be rejected * OTP delivery channel depends on the provided identifier
        
        ---
        
        ### **Response Format**
        
         `application/json`
        
        ---
        
        ### **Sample
        
        Success Response**
        
        ```json { \"status\": \"SUCCESS\", \"message\": \"Validation code sent successfully\" }
        
        ```
        
        ---
        
        ### **Sample
        
        Error Responses**
        
        ### Missing Identifier
        
        ```json { \"status\": \"ERROR\", \"message\": \"Either mobile_number or email_id must be provided\" }
        
        ```
        
        ### Invalid Identifier
        
        ```json { \"status\": \"ERROR\", \"message\": \"Invalid mobile number or email address\" }
        
        ```
        
        ---
        
        ### **Notes**
        * This API **only sends** the validation code
        * OTP verification must be performed using the corresponding **verify validation code** API * Rate limiting and retry restrictions may apply to prevent abuse

        :param app_id: App ID (required)
        :type app_id: str
        :param mobile_number: Mobile number
        :type mobile_number: str
        :param email_id: Email ID
        :type email_id: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._send_sign_in_validation_code_serialize(
            app_id=app_id,
            mobile_number=mobile_number,
            email_id=email_id,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "SendSignInValidationCode200Response",
            '400': "ResetPassword400Response",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        )


    @validate_call
    def send_sign_in_validation_code_without_preload_content(
        self,
        app_id: Annotated[StrictStr, Field(description="App ID")],
        mobile_number: Annotated[Optional[StrictStr], Field(description="Mobile number")] = None,
        email_id: Annotated[Optional[StrictStr], Field(description="Email ID")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> RESTResponseType:
        """Send Sign-In Validation Code (OTP)

        This API initiates the **sign-in validation process** by sending a **one-time validation code (OTP)** to the user. The OTP is delivered to **either the mobile number or the email address** provided in the request. This endpoint is typically called **before completing sign-in**, to verify that the user owns the supplied contact identifier. The calling application is responsible for:
        * Collecting the OTP from the user
        * Submitting it to the OTP verification API (handled separately)
        
        ---
        
        ### **Use Case**
        * User attempts to sign in
        * User provides **mobile number or email** * System sends a **validation code (OTP)**
        * User enters OTP to complete sign-in
        
        ---
        
        ### **Request Method**
        
         `POST`
        
        ---
        
        ### **Formdata Parameters**
        
        | Parameter Name | Type | Required | Description |
        | --------------- | ------ | --------- | ------------------------------------------- |
        | `mobile_number` | String | Optional* | Mobile number to which the OTP will be sent |
        | `email_id` | String | Optional* | Email address to which the OTP will be sent |
        | `app_id` | String | Optional | Identifier of the calling application |
        * **Either `mobile_number` or `email_id` must be provided.** Providing both is allowed; the system may choose one based on configuration.
        
        ---
        
        ### **Request Rules**
        * At least **one** of `mobile_number` or `email_id` is mandatory
        * If both are missing, the request will be rejected * OTP delivery channel depends on the provided identifier
        
        ---
        
        ### **Response Format**
        
         `application/json`
        
        ---
        
        ### **Sample
        
        Success Response**
        
        ```json { \"status\": \"SUCCESS\", \"message\": \"Validation code sent successfully\" }
        
        ```
        
        ---
        
        ### **Sample
        
        Error Responses**
        
        ### Missing Identifier
        
        ```json { \"status\": \"ERROR\", \"message\": \"Either mobile_number or email_id must be provided\" }
        
        ```
        
        ### Invalid Identifier
        
        ```json { \"status\": \"ERROR\", \"message\": \"Invalid mobile number or email address\" }
        
        ```
        
        ---
        
        ### **Notes**
        * This API **only sends** the validation code
        * OTP verification must be performed using the corresponding **verify validation code** API * Rate limiting and retry restrictions may apply to prevent abuse

        :param app_id: App ID (required)
        :type app_id: str
        :param mobile_number: Mobile number
        :type mobile_number: str
        :param email_id: Email ID
        :type email_id: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._send_sign_in_validation_code_serialize(
            app_id=app_id,
            mobile_number=mobile_number,
            email_id=email_id,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "SendSignInValidationCode200Response",
            '400': "ResetPassword400Response",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        return response_data.response


    def _send_sign_in_validation_code_serialize(
        self,
        app_id,
        mobile_number,
        email_id,
        _request_auth,
        _content_type,
        _headers,
        _host_index,
    ) -> RequestSerialized:

        _host = None

        _collection_formats: Dict[str, str] = {
        }

        _path_params: Dict[str, str] = {}
        _query_params: List[Tuple[str, str]] = []
        _header_params: Dict[str, Optional[str]] = _headers or {}
        _form_params: List[Tuple[str, str]] = []
        _files: Dict[
            str, Union[str, bytes, List[str], List[bytes], List[Tuple[str, bytes]]]
        ] = {}
        _body_params: Optional[bytes] = None

        # process the path parameters
        # process the query parameters
        # process the header parameters
        # process the form parameters
        if mobile_number is not None:
            _form_params.append(('mobile_number', mobile_number))
        if email_id is not None:
            _form_params.append(('email_id', email_id))
        if app_id is not None:
            _form_params.append(('app_id', app_id))
        # process the body parameter


        # set the HTTP header `Accept`
        if 'Accept' not in _header_params:
            _header_params['Accept'] = self.api_client.select_header_accept(
                [
                    'application/json'
                ]
            )

        # set the HTTP header `Content-Type`
        if _content_type:
            _header_params['Content-Type'] = _content_type
        else:
            _default_content_type = (
                self.api_client.select_header_content_type(
                    [
                        'multipart/form-data'
                    ]
                )
            )
            if _default_content_type is not None:
                _header_params['Content-Type'] = _default_content_type

        # authentication setting
        _auth_settings: List[str] = [
            'bearer'
        ]

        return self.api_client.param_serialize(
            method='POST',
            resource_path='/auth-service/send/sign/in/validation/code',
            path_params=_path_params,
            query_params=_query_params,
            header_params=_header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            auth_settings=_auth_settings,
            collection_formats=_collection_formats,
            _host=_host,
            _request_auth=_request_auth
        )




    @validate_call
    def send_validation_code(
        self,
        mode: StrictStr,
        user_id: Optional[StrictStr] = None,
        mobile_number: Optional[StrictStr] = None,
        email_id: Optional[StrictStr] = None,
        app_id: Optional[StrictStr] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> SendValidationCode200Response:
        """Send Validation code

        Generates and sends a one-time validation code to the user for verification of sensitive or critical account operations. This API is used across multiple authentication and account-management flows. The validation code is delivered to the user via the appropriate channel (**email or mobile number**), based on the requested operation mode and the input provided. The generated code is **time-bound**, **single-use**, and must be validated using the corresponding verification APIs to complete the requested action.
        
        ---
        
        ### **Usage Scenarios (Mode Definition)**
        
        | Mode | Purpose |
        | ---- | ----------------------------- |
        | `0` | Email or mobile number change |
        | `1` | Password change |
        | `2` | Delete account |
        | `3` | Clear account |
        | `4` | Signup Verification |
        | `5` | Using OTP for Login |
        | `6` | OTP for forgot password |
        
        **Mode `4` – Signup Verification** For login verification, the validation code is sent to **either the email ID or the mobile number provided in the request**. At least **one of email or mobile number must be supplied** for this mode.
        
        ---
        
        ### **Behavior**
        * Generates a secure, one-time validation code
        * Sends the code to the appropriate channel:
        * Email or mobile number, depending on the operation mode and input
        * Associates the code with:
        * User identity (or login identifier)
        * Requested operation (`mode`)
        * Application context (if applicable)
        * Validation codes are valid for a limited duration and **cannot be reused**
        
        ---
        
        ### **Authentication**
        
        This endpoint requires **Bearer Token authentication**, **except** where explicitly allowed (for example, login-related flows).
        
        ``` Authorization: Bearer <access_token>
        
        ```
        
        ---
        
        ### **Successful Response**
        
        On success, the API confirms that the validation code has been generated and successfully dispatched to the user.
        
        ---
        
        ### **Error Response**
        
         The API returns an error response if:
        * The user does not exist or is not eligible for the requested operation
        * The requested mode is invalid or unsupported * Required identifiers (email or mobile number for login verification) are missing * Rate limits are exceeded * Authorization fails (where applicable)
        
        ---
        
        ### **Security
        
        Notes (Recommended)**
        * Validation codes are single-use and time-bound
        * Rate limiting is enforced to prevent abuse * Repeated failures may trigger temporary blocking or additional verification
        
        ---
        
        ### **One-Line Summary**
        
        > Sends a one-time validation code for secure account and authentication operations, including login via email or mobile number.

        :param mode: (required)
        :type mode: str
        :param user_id:
        :type user_id: str
        :param mobile_number:
        :type mobile_number: str
        :param email_id:
        :type email_id: str
        :param app_id:
        :type app_id: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._send_validation_code_serialize(
            mode=mode,
            user_id=user_id,
            mobile_number=mobile_number,
            email_id=email_id,
            app_id=app_id,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "SendValidationCode200Response",
            '400': "GetRecentEvents400Response",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        ).data


    @validate_call
    def send_validation_code_with_http_info(
        self,
        mode: StrictStr,
        user_id: Optional[StrictStr] = None,
        mobile_number: Optional[StrictStr] = None,
        email_id: Optional[StrictStr] = None,
        app_id: Optional[StrictStr] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> ApiResponse[SendValidationCode200Response]:
        """Send Validation code

        Generates and sends a one-time validation code to the user for verification of sensitive or critical account operations. This API is used across multiple authentication and account-management flows. The validation code is delivered to the user via the appropriate channel (**email or mobile number**), based on the requested operation mode and the input provided. The generated code is **time-bound**, **single-use**, and must be validated using the corresponding verification APIs to complete the requested action.
        
        ---
        
        ### **Usage Scenarios (Mode Definition)**
        
        | Mode | Purpose |
        | ---- | ----------------------------- |
        | `0` | Email or mobile number change |
        | `1` | Password change |
        | `2` | Delete account |
        | `3` | Clear account |
        | `4` | Signup Verification |
        | `5` | Using OTP for Login |
        | `6` | OTP for forgot password |
        
        **Mode `4` – Signup Verification** For login verification, the validation code is sent to **either the email ID or the mobile number provided in the request**. At least **one of email or mobile number must be supplied** for this mode.
        
        ---
        
        ### **Behavior**
        * Generates a secure, one-time validation code
        * Sends the code to the appropriate channel:
        * Email or mobile number, depending on the operation mode and input
        * Associates the code with:
        * User identity (or login identifier)
        * Requested operation (`mode`)
        * Application context (if applicable)
        * Validation codes are valid for a limited duration and **cannot be reused**
        
        ---
        
        ### **Authentication**
        
        This endpoint requires **Bearer Token authentication**, **except** where explicitly allowed (for example, login-related flows).
        
        ``` Authorization: Bearer <access_token>
        
        ```
        
        ---
        
        ### **Successful Response**
        
        On success, the API confirms that the validation code has been generated and successfully dispatched to the user.
        
        ---
        
        ### **Error Response**
        
         The API returns an error response if:
        * The user does not exist or is not eligible for the requested operation
        * The requested mode is invalid or unsupported * Required identifiers (email or mobile number for login verification) are missing * Rate limits are exceeded * Authorization fails (where applicable)
        
        ---
        
        ### **Security
        
        Notes (Recommended)**
        * Validation codes are single-use and time-bound
        * Rate limiting is enforced to prevent abuse * Repeated failures may trigger temporary blocking or additional verification
        
        ---
        
        ### **One-Line Summary**
        
        > Sends a one-time validation code for secure account and authentication operations, including login via email or mobile number.

        :param mode: (required)
        :type mode: str
        :param user_id:
        :type user_id: str
        :param mobile_number:
        :type mobile_number: str
        :param email_id:
        :type email_id: str
        :param app_id:
        :type app_id: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._send_validation_code_serialize(
            mode=mode,
            user_id=user_id,
            mobile_number=mobile_number,
            email_id=email_id,
            app_id=app_id,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "SendValidationCode200Response",
            '400': "GetRecentEvents400Response",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        )


    @validate_call
    def send_validation_code_without_preload_content(
        self,
        mode: StrictStr,
        user_id: Optional[StrictStr] = None,
        mobile_number: Optional[StrictStr] = None,
        email_id: Optional[StrictStr] = None,
        app_id: Optional[StrictStr] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> RESTResponseType:
        """Send Validation code

        Generates and sends a one-time validation code to the user for verification of sensitive or critical account operations. This API is used across multiple authentication and account-management flows. The validation code is delivered to the user via the appropriate channel (**email or mobile number**), based on the requested operation mode and the input provided. The generated code is **time-bound**, **single-use**, and must be validated using the corresponding verification APIs to complete the requested action.
        
        ---
        
        ### **Usage Scenarios (Mode Definition)**
        
        | Mode | Purpose |
        | ---- | ----------------------------- |
        | `0` | Email or mobile number change |
        | `1` | Password change |
        | `2` | Delete account |
        | `3` | Clear account |
        | `4` | Signup Verification |
        | `5` | Using OTP for Login |
        | `6` | OTP for forgot password |
        
        **Mode `4` – Signup Verification** For login verification, the validation code is sent to **either the email ID or the mobile number provided in the request**. At least **one of email or mobile number must be supplied** for this mode.
        
        ---
        
        ### **Behavior**
        * Generates a secure, one-time validation code
        * Sends the code to the appropriate channel:
        * Email or mobile number, depending on the operation mode and input
        * Associates the code with:
        * User identity (or login identifier)
        * Requested operation (`mode`)
        * Application context (if applicable)
        * Validation codes are valid for a limited duration and **cannot be reused**
        
        ---
        
        ### **Authentication**
        
        This endpoint requires **Bearer Token authentication**, **except** where explicitly allowed (for example, login-related flows).
        
        ``` Authorization: Bearer <access_token>
        
        ```
        
        ---
        
        ### **Successful Response**
        
        On success, the API confirms that the validation code has been generated and successfully dispatched to the user.
        
        ---
        
        ### **Error Response**
        
         The API returns an error response if:
        * The user does not exist or is not eligible for the requested operation
        * The requested mode is invalid or unsupported * Required identifiers (email or mobile number for login verification) are missing * Rate limits are exceeded * Authorization fails (where applicable)
        
        ---
        
        ### **Security
        
        Notes (Recommended)**
        * Validation codes are single-use and time-bound
        * Rate limiting is enforced to prevent abuse * Repeated failures may trigger temporary blocking or additional verification
        
        ---
        
        ### **One-Line Summary**
        
        > Sends a one-time validation code for secure account and authentication operations, including login via email or mobile number.

        :param mode: (required)
        :type mode: str
        :param user_id:
        :type user_id: str
        :param mobile_number:
        :type mobile_number: str
        :param email_id:
        :type email_id: str
        :param app_id:
        :type app_id: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._send_validation_code_serialize(
            mode=mode,
            user_id=user_id,
            mobile_number=mobile_number,
            email_id=email_id,
            app_id=app_id,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "SendValidationCode200Response",
            '400': "GetRecentEvents400Response",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        return response_data.response


    def _send_validation_code_serialize(
        self,
        mode,
        user_id,
        mobile_number,
        email_id,
        app_id,
        _request_auth,
        _content_type,
        _headers,
        _host_index,
    ) -> RequestSerialized:

        _host = None

        _collection_formats: Dict[str, str] = {
        }

        _path_params: Dict[str, str] = {}
        _query_params: List[Tuple[str, str]] = []
        _header_params: Dict[str, Optional[str]] = _headers or {}
        _form_params: List[Tuple[str, str]] = []
        _files: Dict[
            str, Union[str, bytes, List[str], List[bytes], List[Tuple[str, bytes]]]
        ] = {}
        _body_params: Optional[bytes] = None

        # process the path parameters
        # process the query parameters
        # process the header parameters
        # process the form parameters
        if user_id is not None:
            _form_params.append(('user_id', user_id))
        if mobile_number is not None:
            _form_params.append(('mobile_number', mobile_number))
        if mode is not None:
            _form_params.append(('mode', mode))
        if email_id is not None:
            _form_params.append(('email_id', email_id))
        if app_id is not None:
            _form_params.append(('app_id', app_id))
        # process the body parameter


        # set the HTTP header `Accept`
        if 'Accept' not in _header_params:
            _header_params['Accept'] = self.api_client.select_header_accept(
                [
                    'application/json'
                ]
            )

        # set the HTTP header `Content-Type`
        if _content_type:
            _header_params['Content-Type'] = _content_type
        else:
            _default_content_type = (
                self.api_client.select_header_content_type(
                    [
                        'multipart/form-data'
                    ]
                )
            )
            if _default_content_type is not None:
                _header_params['Content-Type'] = _default_content_type

        # authentication setting
        _auth_settings: List[str] = [
            'bearer'
        ]

        return self.api_client.param_serialize(
            method='POST',
            resource_path='/auth-service/send/validation/code',
            path_params=_path_params,
            query_params=_query_params,
            header_params=_header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            auth_settings=_auth_settings,
            collection_formats=_collection_formats,
            _host=_host,
            _request_auth=_request_auth
        )




    @validate_call
    def sign_in_with_email(
        self,
        email_id: Annotated[StrictStr, Field(description="Email ID")],
        pass_code: Annotated[StrictStr, Field(description="Validation code or password depends on the login_type")],
        login_type: Annotated[StrictStr, Field(description="1 is for password, 2 is for validation code")],
        app_id: Annotated[Optional[StrictStr], Field(description="App ID")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> SignInWithEmail200Response:
        """Sign In with email ID

        Authenticates a user using a registered email ID. The authentication mechanism is determined by the specified `mode`.
        * When `login_type` is set to **`1`**, the user is authenticated using the provided **password**.
        * When `login_type` is set to **`2`**, the user is authenticated using a **one-time activation code (OTP)**. For OTP-based authentication (`login_type = 2`), the client **must first invoke the Send Validation Code API** with the appropriate login mode to generate and deliver the activation code to the user.
        
        ---
        
        ### **Request Body**
        
        | Field | Type | Required | Description |
        | ------------ | ------------- | -------- | ----------------------------------------------------------------- |
        | `email_id` | string | Yes | Email ID |
        | `pass_code` | string | Yes | Password/Validation code depending on the login_type|
        | `login_type` | string | Yes | login type 1 for password 2 for validation code|
        |`app_id` | string | Yes | App ID |
        
        **Field Description**
        * `email_id` – Registered email address of the user
        * `pass_code` – password or activation code (this is password if it is 1 and 2 it is validation code) * `app_id`
        - App ID which is a 13 digit numeric value
        * `login_type` – Login type
        * `1` → Password-based login
        * `2` → Activation code (OTP)–based login
        
        ---
        
        ### **Behavior
        
        Notes**
        * When `login_type = 2`, password validation is bypassed.
        * OTP-based login requires a prior call to ` /auth-service/send/sign/in/validation/code`. * If the required credentials for the selected mode are missing or invalid, authentication fails.
        
        ---
        
        ### **Successful Response**
        
        On successful authentication, the user is signed in and a success response is returned as per the authentication flow.
        
        ---
        
        ### **Error Response**
        
         The API returns an error response if:
        * The email ID is not registered
        * The password is incorrect (`login_type = 1 `) * The activation code is missing, invalid, or expired (`login_type = 2`) * The mode value is invalid or unsupported
        
        ---
        
        ### **One-Line Summary**
        
        > Signs in a user using an email ID with either password-based or OTP-based authentication, based on the selected mode.

        :param email_id: Email ID (required)
        :type email_id: str
        :param pass_code: Validation code or password depends on the login_type (required)
        :type pass_code: str
        :param login_type: 1 is for password, 2 is for validation code (required)
        :type login_type: str
        :param app_id: App ID
        :type app_id: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._sign_in_with_email_serialize(
            email_id=email_id,
            pass_code=pass_code,
            login_type=login_type,
            app_id=app_id,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "SignInWithEmail200Response",
            '400': "GetRecentEvents400Response",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        ).data


    @validate_call
    def sign_in_with_email_with_http_info(
        self,
        email_id: Annotated[StrictStr, Field(description="Email ID")],
        pass_code: Annotated[StrictStr, Field(description="Validation code or password depends on the login_type")],
        login_type: Annotated[StrictStr, Field(description="1 is for password, 2 is for validation code")],
        app_id: Annotated[Optional[StrictStr], Field(description="App ID")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> ApiResponse[SignInWithEmail200Response]:
        """Sign In with email ID

        Authenticates a user using a registered email ID. The authentication mechanism is determined by the specified `mode`.
        * When `login_type` is set to **`1`**, the user is authenticated using the provided **password**.
        * When `login_type` is set to **`2`**, the user is authenticated using a **one-time activation code (OTP)**. For OTP-based authentication (`login_type = 2`), the client **must first invoke the Send Validation Code API** with the appropriate login mode to generate and deliver the activation code to the user.
        
        ---
        
        ### **Request Body**
        
        | Field | Type | Required | Description |
        | ------------ | ------------- | -------- | ----------------------------------------------------------------- |
        | `email_id` | string | Yes | Email ID |
        | `pass_code` | string | Yes | Password/Validation code depending on the login_type|
        | `login_type` | string | Yes | login type 1 for password 2 for validation code|
        |`app_id` | string | Yes | App ID |
        
        **Field Description**
        * `email_id` – Registered email address of the user
        * `pass_code` – password or activation code (this is password if it is 1 and 2 it is validation code) * `app_id`
        - App ID which is a 13 digit numeric value
        * `login_type` – Login type
        * `1` → Password-based login
        * `2` → Activation code (OTP)–based login
        
        ---
        
        ### **Behavior
        
        Notes**
        * When `login_type = 2`, password validation is bypassed.
        * OTP-based login requires a prior call to ` /auth-service/send/sign/in/validation/code`. * If the required credentials for the selected mode are missing or invalid, authentication fails.
        
        ---
        
        ### **Successful Response**
        
        On successful authentication, the user is signed in and a success response is returned as per the authentication flow.
        
        ---
        
        ### **Error Response**
        
         The API returns an error response if:
        * The email ID is not registered
        * The password is incorrect (`login_type = 1 `) * The activation code is missing, invalid, or expired (`login_type = 2`) * The mode value is invalid or unsupported
        
        ---
        
        ### **One-Line Summary**
        
        > Signs in a user using an email ID with either password-based or OTP-based authentication, based on the selected mode.

        :param email_id: Email ID (required)
        :type email_id: str
        :param pass_code: Validation code or password depends on the login_type (required)
        :type pass_code: str
        :param login_type: 1 is for password, 2 is for validation code (required)
        :type login_type: str
        :param app_id: App ID
        :type app_id: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._sign_in_with_email_serialize(
            email_id=email_id,
            pass_code=pass_code,
            login_type=login_type,
            app_id=app_id,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "SignInWithEmail200Response",
            '400': "GetRecentEvents400Response",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        )


    @validate_call
    def sign_in_with_email_without_preload_content(
        self,
        email_id: Annotated[StrictStr, Field(description="Email ID")],
        pass_code: Annotated[StrictStr, Field(description="Validation code or password depends on the login_type")],
        login_type: Annotated[StrictStr, Field(description="1 is for password, 2 is for validation code")],
        app_id: Annotated[Optional[StrictStr], Field(description="App ID")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> RESTResponseType:
        """Sign In with email ID

        Authenticates a user using a registered email ID. The authentication mechanism is determined by the specified `mode`.
        * When `login_type` is set to **`1`**, the user is authenticated using the provided **password**.
        * When `login_type` is set to **`2`**, the user is authenticated using a **one-time activation code (OTP)**. For OTP-based authentication (`login_type = 2`), the client **must first invoke the Send Validation Code API** with the appropriate login mode to generate and deliver the activation code to the user.
        
        ---
        
        ### **Request Body**
        
        | Field | Type | Required | Description |
        | ------------ | ------------- | -------- | ----------------------------------------------------------------- |
        | `email_id` | string | Yes | Email ID |
        | `pass_code` | string | Yes | Password/Validation code depending on the login_type|
        | `login_type` | string | Yes | login type 1 for password 2 for validation code|
        |`app_id` | string | Yes | App ID |
        
        **Field Description**
        * `email_id` – Registered email address of the user
        * `pass_code` – password or activation code (this is password if it is 1 and 2 it is validation code) * `app_id`
        - App ID which is a 13 digit numeric value
        * `login_type` – Login type
        * `1` → Password-based login
        * `2` → Activation code (OTP)–based login
        
        ---
        
        ### **Behavior
        
        Notes**
        * When `login_type = 2`, password validation is bypassed.
        * OTP-based login requires a prior call to ` /auth-service/send/sign/in/validation/code`. * If the required credentials for the selected mode are missing or invalid, authentication fails.
        
        ---
        
        ### **Successful Response**
        
        On successful authentication, the user is signed in and a success response is returned as per the authentication flow.
        
        ---
        
        ### **Error Response**
        
         The API returns an error response if:
        * The email ID is not registered
        * The password is incorrect (`login_type = 1 `) * The activation code is missing, invalid, or expired (`login_type = 2`) * The mode value is invalid or unsupported
        
        ---
        
        ### **One-Line Summary**
        
        > Signs in a user using an email ID with either password-based or OTP-based authentication, based on the selected mode.

        :param email_id: Email ID (required)
        :type email_id: str
        :param pass_code: Validation code or password depends on the login_type (required)
        :type pass_code: str
        :param login_type: 1 is for password, 2 is for validation code (required)
        :type login_type: str
        :param app_id: App ID
        :type app_id: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._sign_in_with_email_serialize(
            email_id=email_id,
            pass_code=pass_code,
            login_type=login_type,
            app_id=app_id,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "SignInWithEmail200Response",
            '400': "GetRecentEvents400Response",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        return response_data.response


    def _sign_in_with_email_serialize(
        self,
        email_id,
        pass_code,
        login_type,
        app_id,
        _request_auth,
        _content_type,
        _headers,
        _host_index,
    ) -> RequestSerialized:

        _host = None

        _collection_formats: Dict[str, str] = {
        }

        _path_params: Dict[str, str] = {}
        _query_params: List[Tuple[str, str]] = []
        _header_params: Dict[str, Optional[str]] = _headers or {}
        _form_params: List[Tuple[str, str]] = []
        _files: Dict[
            str, Union[str, bytes, List[str], List[bytes], List[Tuple[str, bytes]]]
        ] = {}
        _body_params: Optional[bytes] = None

        # process the path parameters
        # process the query parameters
        # process the header parameters
        # process the form parameters
        if email_id is not None:
            _form_params.append(('email_id', email_id))
        if pass_code is not None:
            _form_params.append(('pass_code', pass_code))
        if login_type is not None:
            _form_params.append(('login_type', login_type))
        if app_id is not None:
            _form_params.append(('app_id', app_id))
        # process the body parameter


        # set the HTTP header `Accept`
        if 'Accept' not in _header_params:
            _header_params['Accept'] = self.api_client.select_header_accept(
                [
                    'application/json'
                ]
            )

        # set the HTTP header `Content-Type`
        if _content_type:
            _header_params['Content-Type'] = _content_type
        else:
            _default_content_type = (
                self.api_client.select_header_content_type(
                    [
                        'multipart/form-data'
                    ]
                )
            )
            if _default_content_type is not None:
                _header_params['Content-Type'] = _default_content_type

        # authentication setting
        _auth_settings: List[str] = [
            'bearer'
        ]

        return self.api_client.param_serialize(
            method='POST',
            resource_path='/auth-service/sign/in/with/email',
            path_params=_path_params,
            query_params=_query_params,
            header_params=_header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            auth_settings=_auth_settings,
            collection_formats=_collection_formats,
            _host=_host,
            _request_auth=_request_auth
        )




    @validate_call
    def sign_in_with_mobile_number(
        self,
        mobile_number: Annotated[StrictStr, Field(description="Mobile number")],
        pass_code: Annotated[StrictStr, Field(description="Pass code takes either password or validation code depending on the login_type")],
        login_type: Annotated[StrictStr, Field(description="1 for password, 2 for activate code")],
        app_id: Annotated[Optional[StrictStr], Field(description="App ID")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> SignInWithEmail200Response:
        """Sign In with Mobile number

        Authenticates a user using a registered mobile number. The authentication method is determined by the specified `mode`.
        * When `login_type` is set to **`1`**, the user is authenticated using the **password** associated with the account.
        * When `login_type` is set to **`2`**, the user is authenticated using a **one-time activation code (OTP)** sent to the registered mobile number. For OTP-based authentication (`login_type = 1`), the client **must first call the Send Validation Code API** with the appropriate login mode to generate and deliver the activation code.
        
        ---
        
        ### **Request Formdata**
        
        | Field | Type | Required | Description |
        | ------------ | ------------- | -------- | ----------------------------------------------------------------- |
        | `mobile_number` | string | Yes | Mobile number|
        | `pass_code` | string | Yes | Password/Validation code depending on the login_type|
        | `login_type` | string | Yes | login type 1 for password 2 for validation code|
        |`app_id` | string | Yes | App ID |
        
        **Field Description**
        * `mobile_number` – Registered mobile number of the user
        * `pass_code` – Password / Validation code (password when `login_type= 1`; validation code when `login_type = 2`) * `login_type` – Login type
        * `1` → Password-based login
        * `2` → Activation code (OTP)–based login
        
        ---
        
        ### **Behavior
        
        Notes**
        * When `login_type = 2`, password validation is skipped.
        * OTP-based login requires a prior call to `/auth-service/send/sign/in/validation/code`. * Missing or invalid credentials for the selected mode will result in authentication failure.
        
        ---
        
        ### **Successful Response**
        
        On successful authentication, the user is signed in and a success response is returned according to the authentication flow.
        
        ---
        
        ### **Error Response**
        
         The API returns an error response if:
        * The mobile number is not registered
        * The password is incorrect (`login_type = 1`) * The activation code is missing, invalid, or expired (`login_type = 2`) * An invalid or unsupported mode is provided
        
        ---
        
        ### **One-Line Summary**
        
        > Signs in a user using a mobile number with either password-based or OTP-based authentication, based on the selected mode.

        :param mobile_number: Mobile number (required)
        :type mobile_number: str
        :param pass_code: Pass code takes either password or validation code depending on the login_type (required)
        :type pass_code: str
        :param login_type: 1 for password, 2 for activate code (required)
        :type login_type: str
        :param app_id: App ID
        :type app_id: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._sign_in_with_mobile_number_serialize(
            mobile_number=mobile_number,
            pass_code=pass_code,
            login_type=login_type,
            app_id=app_id,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "SignInWithEmail200Response",
            '400': "GetRecentEvents400Response",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        ).data


    @validate_call
    def sign_in_with_mobile_number_with_http_info(
        self,
        mobile_number: Annotated[StrictStr, Field(description="Mobile number")],
        pass_code: Annotated[StrictStr, Field(description="Pass code takes either password or validation code depending on the login_type")],
        login_type: Annotated[StrictStr, Field(description="1 for password, 2 for activate code")],
        app_id: Annotated[Optional[StrictStr], Field(description="App ID")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> ApiResponse[SignInWithEmail200Response]:
        """Sign In with Mobile number

        Authenticates a user using a registered mobile number. The authentication method is determined by the specified `mode`.
        * When `login_type` is set to **`1`**, the user is authenticated using the **password** associated with the account.
        * When `login_type` is set to **`2`**, the user is authenticated using a **one-time activation code (OTP)** sent to the registered mobile number. For OTP-based authentication (`login_type = 1`), the client **must first call the Send Validation Code API** with the appropriate login mode to generate and deliver the activation code.
        
        ---
        
        ### **Request Formdata**
        
        | Field | Type | Required | Description |
        | ------------ | ------------- | -------- | ----------------------------------------------------------------- |
        | `mobile_number` | string | Yes | Mobile number|
        | `pass_code` | string | Yes | Password/Validation code depending on the login_type|
        | `login_type` | string | Yes | login type 1 for password 2 for validation code|
        |`app_id` | string | Yes | App ID |
        
        **Field Description**
        * `mobile_number` – Registered mobile number of the user
        * `pass_code` – Password / Validation code (password when `login_type= 1`; validation code when `login_type = 2`) * `login_type` – Login type
        * `1` → Password-based login
        * `2` → Activation code (OTP)–based login
        
        ---
        
        ### **Behavior
        
        Notes**
        * When `login_type = 2`, password validation is skipped.
        * OTP-based login requires a prior call to `/auth-service/send/sign/in/validation/code`. * Missing or invalid credentials for the selected mode will result in authentication failure.
        
        ---
        
        ### **Successful Response**
        
        On successful authentication, the user is signed in and a success response is returned according to the authentication flow.
        
        ---
        
        ### **Error Response**
        
         The API returns an error response if:
        * The mobile number is not registered
        * The password is incorrect (`login_type = 1`) * The activation code is missing, invalid, or expired (`login_type = 2`) * An invalid or unsupported mode is provided
        
        ---
        
        ### **One-Line Summary**
        
        > Signs in a user using a mobile number with either password-based or OTP-based authentication, based on the selected mode.

        :param mobile_number: Mobile number (required)
        :type mobile_number: str
        :param pass_code: Pass code takes either password or validation code depending on the login_type (required)
        :type pass_code: str
        :param login_type: 1 for password, 2 for activate code (required)
        :type login_type: str
        :param app_id: App ID
        :type app_id: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._sign_in_with_mobile_number_serialize(
            mobile_number=mobile_number,
            pass_code=pass_code,
            login_type=login_type,
            app_id=app_id,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "SignInWithEmail200Response",
            '400': "GetRecentEvents400Response",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        )


    @validate_call
    def sign_in_with_mobile_number_without_preload_content(
        self,
        mobile_number: Annotated[StrictStr, Field(description="Mobile number")],
        pass_code: Annotated[StrictStr, Field(description="Pass code takes either password or validation code depending on the login_type")],
        login_type: Annotated[StrictStr, Field(description="1 for password, 2 for activate code")],
        app_id: Annotated[Optional[StrictStr], Field(description="App ID")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> RESTResponseType:
        """Sign In with Mobile number

        Authenticates a user using a registered mobile number. The authentication method is determined by the specified `mode`.
        * When `login_type` is set to **`1`**, the user is authenticated using the **password** associated with the account.
        * When `login_type` is set to **`2`**, the user is authenticated using a **one-time activation code (OTP)** sent to the registered mobile number. For OTP-based authentication (`login_type = 1`), the client **must first call the Send Validation Code API** with the appropriate login mode to generate and deliver the activation code.
        
        ---
        
        ### **Request Formdata**
        
        | Field | Type | Required | Description |
        | ------------ | ------------- | -------- | ----------------------------------------------------------------- |
        | `mobile_number` | string | Yes | Mobile number|
        | `pass_code` | string | Yes | Password/Validation code depending on the login_type|
        | `login_type` | string | Yes | login type 1 for password 2 for validation code|
        |`app_id` | string | Yes | App ID |
        
        **Field Description**
        * `mobile_number` – Registered mobile number of the user
        * `pass_code` – Password / Validation code (password when `login_type= 1`; validation code when `login_type = 2`) * `login_type` – Login type
        * `1` → Password-based login
        * `2` → Activation code (OTP)–based login
        
        ---
        
        ### **Behavior
        
        Notes**
        * When `login_type = 2`, password validation is skipped.
        * OTP-based login requires a prior call to `/auth-service/send/sign/in/validation/code`. * Missing or invalid credentials for the selected mode will result in authentication failure.
        
        ---
        
        ### **Successful Response**
        
        On successful authentication, the user is signed in and a success response is returned according to the authentication flow.
        
        ---
        
        ### **Error Response**
        
         The API returns an error response if:
        * The mobile number is not registered
        * The password is incorrect (`login_type = 1`) * The activation code is missing, invalid, or expired (`login_type = 2`) * An invalid or unsupported mode is provided
        
        ---
        
        ### **One-Line Summary**
        
        > Signs in a user using a mobile number with either password-based or OTP-based authentication, based on the selected mode.

        :param mobile_number: Mobile number (required)
        :type mobile_number: str
        :param pass_code: Pass code takes either password or validation code depending on the login_type (required)
        :type pass_code: str
        :param login_type: 1 for password, 2 for activate code (required)
        :type login_type: str
        :param app_id: App ID
        :type app_id: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._sign_in_with_mobile_number_serialize(
            mobile_number=mobile_number,
            pass_code=pass_code,
            login_type=login_type,
            app_id=app_id,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "SignInWithEmail200Response",
            '400': "GetRecentEvents400Response",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        return response_data.response


    def _sign_in_with_mobile_number_serialize(
        self,
        mobile_number,
        pass_code,
        login_type,
        app_id,
        _request_auth,
        _content_type,
        _headers,
        _host_index,
    ) -> RequestSerialized:

        _host = None

        _collection_formats: Dict[str, str] = {
        }

        _path_params: Dict[str, str] = {}
        _query_params: List[Tuple[str, str]] = []
        _header_params: Dict[str, Optional[str]] = _headers or {}
        _form_params: List[Tuple[str, str]] = []
        _files: Dict[
            str, Union[str, bytes, List[str], List[bytes], List[Tuple[str, bytes]]]
        ] = {}
        _body_params: Optional[bytes] = None

        # process the path parameters
        # process the query parameters
        # process the header parameters
        # process the form parameters
        if mobile_number is not None:
            _form_params.append(('mobile_number', mobile_number))
        if pass_code is not None:
            _form_params.append(('pass_code', pass_code))
        if login_type is not None:
            _form_params.append(('login_type', login_type))
        if app_id is not None:
            _form_params.append(('app_id', app_id))
        # process the body parameter


        # set the HTTP header `Accept`
        if 'Accept' not in _header_params:
            _header_params['Accept'] = self.api_client.select_header_accept(
                [
                    'application/json'
                ]
            )

        # set the HTTP header `Content-Type`
        if _content_type:
            _header_params['Content-Type'] = _content_type
        else:
            _default_content_type = (
                self.api_client.select_header_content_type(
                    [
                        'multipart/form-data'
                    ]
                )
            )
            if _default_content_type is not None:
                _header_params['Content-Type'] = _default_content_type

        # authentication setting
        _auth_settings: List[str] = [
            'bearer'
        ]

        return self.api_client.param_serialize(
            method='POST',
            resource_path='/auth-service/sign/in/with/mobile/number',
            path_params=_path_params,
            query_params=_query_params,
            header_params=_header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            auth_settings=_auth_settings,
            collection_formats=_collection_formats,
            _host=_host,
            _request_auth=_request_auth
        )




    @validate_call
    def sign_up(
        self,
        name: Annotated[StrictStr, Field(description="New User Name")],
        password: Annotated[StrictStr, Field(description="Password")],
        email_id: Annotated[Optional[StrictStr], Field(description="Email ID of the user")] = None,
        mobile_number: Annotated[Optional[StrictStr], Field(description="Mobile number")] = None,
        app_id: Annotated[Optional[StrictStr], Field(description="Registered App ID")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> SignUp200Response:
        """Sign Up

        Creates a new user account in the Floor POD using **either a mobile number or an email ID**. At least **one of `mobile_number` or `email_id` is required** to register a user. Both may be provided if available. The API registers the user under the specified application context and prepares the account for subsequent authentication and usage. Upon successful registration, the API returns: - a unique user_id identifying the newly created user, and - a success string indicating the outcome of the sign-up operation. The user account is created under the specified application context and can be used for subsequent interactions with Floor POD APIs.
        
        ---
        
        ### **Parameter Clarification (Recommended)**
        * `name` is mandatory for user profile creation
        * Either `mobile_number` **or** `email_id` must be present * `app_id` is optional and used to associate the user with a specific application

        :param name: New User Name (required)
        :type name: str
        :param password: Password (required)
        :type password: str
        :param email_id: Email ID of the user
        :type email_id: str
        :param mobile_number: Mobile number
        :type mobile_number: str
        :param app_id: Registered App ID
        :type app_id: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._sign_up_serialize(
            name=name,
            password=password,
            email_id=email_id,
            mobile_number=mobile_number,
            app_id=app_id,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "SignUp200Response",
            '400': "GetRecentEvents400Response",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        ).data


    @validate_call
    def sign_up_with_http_info(
        self,
        name: Annotated[StrictStr, Field(description="New User Name")],
        password: Annotated[StrictStr, Field(description="Password")],
        email_id: Annotated[Optional[StrictStr], Field(description="Email ID of the user")] = None,
        mobile_number: Annotated[Optional[StrictStr], Field(description="Mobile number")] = None,
        app_id: Annotated[Optional[StrictStr], Field(description="Registered App ID")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> ApiResponse[SignUp200Response]:
        """Sign Up

        Creates a new user account in the Floor POD using **either a mobile number or an email ID**. At least **one of `mobile_number` or `email_id` is required** to register a user. Both may be provided if available. The API registers the user under the specified application context and prepares the account for subsequent authentication and usage. Upon successful registration, the API returns: - a unique user_id identifying the newly created user, and - a success string indicating the outcome of the sign-up operation. The user account is created under the specified application context and can be used for subsequent interactions with Floor POD APIs.
        
        ---
        
        ### **Parameter Clarification (Recommended)**
        * `name` is mandatory for user profile creation
        * Either `mobile_number` **or** `email_id` must be present * `app_id` is optional and used to associate the user with a specific application

        :param name: New User Name (required)
        :type name: str
        :param password: Password (required)
        :type password: str
        :param email_id: Email ID of the user
        :type email_id: str
        :param mobile_number: Mobile number
        :type mobile_number: str
        :param app_id: Registered App ID
        :type app_id: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._sign_up_serialize(
            name=name,
            password=password,
            email_id=email_id,
            mobile_number=mobile_number,
            app_id=app_id,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "SignUp200Response",
            '400': "GetRecentEvents400Response",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        )


    @validate_call
    def sign_up_without_preload_content(
        self,
        name: Annotated[StrictStr, Field(description="New User Name")],
        password: Annotated[StrictStr, Field(description="Password")],
        email_id: Annotated[Optional[StrictStr], Field(description="Email ID of the user")] = None,
        mobile_number: Annotated[Optional[StrictStr], Field(description="Mobile number")] = None,
        app_id: Annotated[Optional[StrictStr], Field(description="Registered App ID")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> RESTResponseType:
        """Sign Up

        Creates a new user account in the Floor POD using **either a mobile number or an email ID**. At least **one of `mobile_number` or `email_id` is required** to register a user. Both may be provided if available. The API registers the user under the specified application context and prepares the account for subsequent authentication and usage. Upon successful registration, the API returns: - a unique user_id identifying the newly created user, and - a success string indicating the outcome of the sign-up operation. The user account is created under the specified application context and can be used for subsequent interactions with Floor POD APIs.
        
        ---
        
        ### **Parameter Clarification (Recommended)**
        * `name` is mandatory for user profile creation
        * Either `mobile_number` **or** `email_id` must be present * `app_id` is optional and used to associate the user with a specific application

        :param name: New User Name (required)
        :type name: str
        :param password: Password (required)
        :type password: str
        :param email_id: Email ID of the user
        :type email_id: str
        :param mobile_number: Mobile number
        :type mobile_number: str
        :param app_id: Registered App ID
        :type app_id: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._sign_up_serialize(
            name=name,
            password=password,
            email_id=email_id,
            mobile_number=mobile_number,
            app_id=app_id,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "SignUp200Response",
            '400': "GetRecentEvents400Response",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        return response_data.response


    def _sign_up_serialize(
        self,
        name,
        password,
        email_id,
        mobile_number,
        app_id,
        _request_auth,
        _content_type,
        _headers,
        _host_index,
    ) -> RequestSerialized:

        _host = None

        _collection_formats: Dict[str, str] = {
        }

        _path_params: Dict[str, str] = {}
        _query_params: List[Tuple[str, str]] = []
        _header_params: Dict[str, Optional[str]] = _headers or {}
        _form_params: List[Tuple[str, str]] = []
        _files: Dict[
            str, Union[str, bytes, List[str], List[bytes], List[Tuple[str, bytes]]]
        ] = {}
        _body_params: Optional[bytes] = None

        # process the path parameters
        # process the query parameters
        # process the header parameters
        # process the form parameters
        if name is not None:
            _form_params.append(('name', name))
        if email_id is not None:
            _form_params.append(('email_id', email_id))
        if mobile_number is not None:
            _form_params.append(('mobile_number', mobile_number))
        if password is not None:
            _form_params.append(('password', password))
        if app_id is not None:
            _form_params.append(('app_id', app_id))
        # process the body parameter


        # set the HTTP header `Accept`
        if 'Accept' not in _header_params:
            _header_params['Accept'] = self.api_client.select_header_accept(
                [
                    'application/json'
                ]
            )

        # set the HTTP header `Content-Type`
        if _content_type:
            _header_params['Content-Type'] = _content_type
        else:
            _default_content_type = (
                self.api_client.select_header_content_type(
                    [
                        'multipart/form-data'
                    ]
                )
            )
            if _default_content_type is not None:
                _header_params['Content-Type'] = _default_content_type

        # authentication setting
        _auth_settings: List[str] = [
            'bearer'
        ]

        return self.api_client.param_serialize(
            method='POST',
            resource_path='/auth-service/sign/up',
            path_params=_path_params,
            query_params=_query_params,
            header_params=_header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            auth_settings=_auth_settings,
            collection_formats=_collection_formats,
            _host=_host,
            _request_auth=_request_auth
        )




    @validate_call
    def validate_code(
        self,
        validate_code_request: ValidateCodeRequest,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> UserDetails:
        """Validation

        ### **Validate Activation / Verification Code**
        
        This API **validates a one-time verification code** submitted by a user and **executes the corresponding account operation** based on the specified **mode**. Depending on the mode, the API may:
        * Activate a newly registered account
        * Confirm a login attempt * Verify a password change or reset * Validate email or mobile updates * Confirm account deletion or clearing requests The API verifies the provided `activation_code` against the given `user_id`, `mode`, and application context. If validation succeeds, the requested operation is completed and the API returns the relevant **POD information** and **user profile details** (where applicable). If validation fails, the operation is **not performed** and an appropriate error response is returned.
        
        ---
        
        ### **Authentication**
        
        This endpoint requires **Bearer Token authentication**. **Header**
        
        ``` Authorization: Bearer <access_token>
        
        ```
        
        ---
        
        ### **Request Body**
        
        ```json { \"user_id\": \"string\", \"activation_code\": \"string\", \"app_id\": \"string\", \"mode\": \"string\" }
        
        ```
        
        ### **Field Descriptions**
        * **user_id** – Unique identifier of the user initiating the operation
        * **activation_code** – One-time verification code sent to the user * **app_id** – Application identifier (optional or context-specific) * **mode** – Operation context for which the verification is being performed
        
        ---
        
        ### **Usage Scenarios (Mode Definitions)**
        
        | Mode | Purpose |
        | ---- | ---------------------------------------- |
        | 0 | Email or mobile number change |
        | 1 | Password change |
        | 2 | Delete account |
        | 3 | Clear account |
        | 4 | Signup verification (account activation) |
        | 5 | Login verification |
        | 6 | Forgot password verification |
        
        ---
        
        ### **Successful Response**
        
        On successful validation:
        * The requested operation (based on `mode`) is completed
        * The API returns:
        * **POD information** associated with the user (if applicable)
        * **User profile details** (if applicable) Examples:
        * For **signup verification**, the user account is activated
        * For **login**, access is confirmed * For **password reset**, the user may proceed to set a new password * For **account deletion**, the request is confirmed
        
        ---
        
        ### **Error Response**
        
         The API returns an error response when:
        * The activation code is invalid or expired
        * The activation code does not match the user or operation mode * The requested operation is already completed (e.g., user already activated) * Authorization fails or the bearer token is missing or invalid ⚠️ In all error cases, **no account state change occurs**.
        
        ---
        
        ### **One-Line Summary**
        
        > Validates a one-time verification code and securely completes the requested user account operation (signup, login, password change, or account actions), returning POD and profile details on success.

        :param validate_code_request: (required)
        :type validate_code_request: ValidateCodeRequest
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._validate_code_serialize(
            validate_code_request=validate_code_request,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "UserDetails",
            '400': "ValidateCode400Response",
            '412': "ValidateCode412Response",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        ).data


    @validate_call
    def validate_code_with_http_info(
        self,
        validate_code_request: ValidateCodeRequest,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> ApiResponse[UserDetails]:
        """Validation

        ### **Validate Activation / Verification Code**
        
        This API **validates a one-time verification code** submitted by a user and **executes the corresponding account operation** based on the specified **mode**. Depending on the mode, the API may:
        * Activate a newly registered account
        * Confirm a login attempt * Verify a password change or reset * Validate email or mobile updates * Confirm account deletion or clearing requests The API verifies the provided `activation_code` against the given `user_id`, `mode`, and application context. If validation succeeds, the requested operation is completed and the API returns the relevant **POD information** and **user profile details** (where applicable). If validation fails, the operation is **not performed** and an appropriate error response is returned.
        
        ---
        
        ### **Authentication**
        
        This endpoint requires **Bearer Token authentication**. **Header**
        
        ``` Authorization: Bearer <access_token>
        
        ```
        
        ---
        
        ### **Request Body**
        
        ```json { \"user_id\": \"string\", \"activation_code\": \"string\", \"app_id\": \"string\", \"mode\": \"string\" }
        
        ```
        
        ### **Field Descriptions**
        * **user_id** – Unique identifier of the user initiating the operation
        * **activation_code** – One-time verification code sent to the user * **app_id** – Application identifier (optional or context-specific) * **mode** – Operation context for which the verification is being performed
        
        ---
        
        ### **Usage Scenarios (Mode Definitions)**
        
        | Mode | Purpose |
        | ---- | ---------------------------------------- |
        | 0 | Email or mobile number change |
        | 1 | Password change |
        | 2 | Delete account |
        | 3 | Clear account |
        | 4 | Signup verification (account activation) |
        | 5 | Login verification |
        | 6 | Forgot password verification |
        
        ---
        
        ### **Successful Response**
        
        On successful validation:
        * The requested operation (based on `mode`) is completed
        * The API returns:
        * **POD information** associated with the user (if applicable)
        * **User profile details** (if applicable) Examples:
        * For **signup verification**, the user account is activated
        * For **login**, access is confirmed * For **password reset**, the user may proceed to set a new password * For **account deletion**, the request is confirmed
        
        ---
        
        ### **Error Response**
        
         The API returns an error response when:
        * The activation code is invalid or expired
        * The activation code does not match the user or operation mode * The requested operation is already completed (e.g., user already activated) * Authorization fails or the bearer token is missing or invalid ⚠️ In all error cases, **no account state change occurs**.
        
        ---
        
        ### **One-Line Summary**
        
        > Validates a one-time verification code and securely completes the requested user account operation (signup, login, password change, or account actions), returning POD and profile details on success.

        :param validate_code_request: (required)
        :type validate_code_request: ValidateCodeRequest
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._validate_code_serialize(
            validate_code_request=validate_code_request,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "UserDetails",
            '400': "ValidateCode400Response",
            '412': "ValidateCode412Response",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        )


    @validate_call
    def validate_code_without_preload_content(
        self,
        validate_code_request: ValidateCodeRequest,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> RESTResponseType:
        """Validation

        ### **Validate Activation / Verification Code**
        
        This API **validates a one-time verification code** submitted by a user and **executes the corresponding account operation** based on the specified **mode**. Depending on the mode, the API may:
        * Activate a newly registered account
        * Confirm a login attempt * Verify a password change or reset * Validate email or mobile updates * Confirm account deletion or clearing requests The API verifies the provided `activation_code` against the given `user_id`, `mode`, and application context. If validation succeeds, the requested operation is completed and the API returns the relevant **POD information** and **user profile details** (where applicable). If validation fails, the operation is **not performed** and an appropriate error response is returned.
        
        ---
        
        ### **Authentication**
        
        This endpoint requires **Bearer Token authentication**. **Header**
        
        ``` Authorization: Bearer <access_token>
        
        ```
        
        ---
        
        ### **Request Body**
        
        ```json { \"user_id\": \"string\", \"activation_code\": \"string\", \"app_id\": \"string\", \"mode\": \"string\" }
        
        ```
        
        ### **Field Descriptions**
        * **user_id** – Unique identifier of the user initiating the operation
        * **activation_code** – One-time verification code sent to the user * **app_id** – Application identifier (optional or context-specific) * **mode** – Operation context for which the verification is being performed
        
        ---
        
        ### **Usage Scenarios (Mode Definitions)**
        
        | Mode | Purpose |
        | ---- | ---------------------------------------- |
        | 0 | Email or mobile number change |
        | 1 | Password change |
        | 2 | Delete account |
        | 3 | Clear account |
        | 4 | Signup verification (account activation) |
        | 5 | Login verification |
        | 6 | Forgot password verification |
        
        ---
        
        ### **Successful Response**
        
        On successful validation:
        * The requested operation (based on `mode`) is completed
        * The API returns:
        * **POD information** associated with the user (if applicable)
        * **User profile details** (if applicable) Examples:
        * For **signup verification**, the user account is activated
        * For **login**, access is confirmed * For **password reset**, the user may proceed to set a new password * For **account deletion**, the request is confirmed
        
        ---
        
        ### **Error Response**
        
         The API returns an error response when:
        * The activation code is invalid or expired
        * The activation code does not match the user or operation mode * The requested operation is already completed (e.g., user already activated) * Authorization fails or the bearer token is missing or invalid ⚠️ In all error cases, **no account state change occurs**.
        
        ---
        
        ### **One-Line Summary**
        
        > Validates a one-time verification code and securely completes the requested user account operation (signup, login, password change, or account actions), returning POD and profile details on success.

        :param validate_code_request: (required)
        :type validate_code_request: ValidateCodeRequest
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._validate_code_serialize(
            validate_code_request=validate_code_request,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "UserDetails",
            '400': "ValidateCode400Response",
            '412': "ValidateCode412Response",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        return response_data.response


    def _validate_code_serialize(
        self,
        validate_code_request,
        _request_auth,
        _content_type,
        _headers,
        _host_index,
    ) -> RequestSerialized:

        _host = None

        _collection_formats: Dict[str, str] = {
        }

        _path_params: Dict[str, str] = {}
        _query_params: List[Tuple[str, str]] = []
        _header_params: Dict[str, Optional[str]] = _headers or {}
        _form_params: List[Tuple[str, str]] = []
        _files: Dict[
            str, Union[str, bytes, List[str], List[bytes], List[Tuple[str, bytes]]]
        ] = {}
        _body_params: Optional[bytes] = None

        # process the path parameters
        # process the query parameters
        # process the header parameters
        # process the form parameters
        # process the body parameter
        if validate_code_request is not None:
            _body_params = validate_code_request


        # set the HTTP header `Accept`
        if 'Accept' not in _header_params:
            _header_params['Accept'] = self.api_client.select_header_accept(
                [
                    'application/json'
                ]
            )

        # set the HTTP header `Content-Type`
        if _content_type:
            _header_params['Content-Type'] = _content_type
        else:
            _default_content_type = (
                self.api_client.select_header_content_type(
                    [
                        'application/json'
                    ]
                )
            )
            if _default_content_type is not None:
                _header_params['Content-Type'] = _default_content_type

        # authentication setting
        _auth_settings: List[str] = [
            'bearer'
        ]

        return self.api_client.param_serialize(
            method='POST',
            resource_path='/auth-service/validate/activation/code',
            path_params=_path_params,
            query_params=_query_params,
            header_params=_header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            auth_settings=_auth_settings,
            collection_formats=_collection_formats,
            _host=_host,
            _request_auth=_request_auth
        )


